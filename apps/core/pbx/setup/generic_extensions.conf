;--------------------------------------------------------------------------------;
; Do NOT edit this file as it is auto-generated by FreePBX. All modifications to ;
; this file must be done via the web gui. There are alternative files to make    ;
; custom modifications, details at: http://freepbx.org/configuration_files       ;
;--------------------------------------------------------------------------------;
;
; This file is part of FreePBX.
;
;    FreePBX is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 2 of the License, or
;    (at your option) any later version.
;
;    FreePBX is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with FreePBX.  If not, see <http://www.gnu.org/licenses/>.
;
; Copyright (C) 2004 Coalescent Systems Inc (Canada)
; Copyright (C) 2006 Why Pay More 4 Less Pty Ltd (Australia)
; Copyright (C) 2007 Astrogen LLC (USA)

; dialparties.agi (http://www.sprackett.com/asterisk/)
; Asterisk::AGI (http://asterisk.gnuinter.net/)
; gsm (http://www.ibiblio.org/pub/Linux/utils/compress/!INDEX.short.html)
; loligo sounds (http://www.loligo.com/asterisk/sounds/)
; mpg123 (http://voip-info.org/wiki-Asterisk+config+musiconhold.conf)


; include extension contexts generated from AMP
#include organizations/extensions_additionals_{DOMAIN}.conf

; Customizations to this dialplan should be made in extensions_custom.conf
; See extensions_custom.conf.sample for an example.
; If you need to use [macro-dialout-trunk-predial-hook], [ext-did-custom], or
; [from-internal-custom] for example, place these in this file or they will get overwritten.
;
#include organizations/extensions_custom_{DOMAIN}.conf

[{CODE}-from-digital]
include => {CODE}-from-pstn

[{CODE}-from-analog]
include => {CODE}-from-dahdi

[{CODE}-from-trunk]				; just an alias since VoIP shouldn't be called PSTN
include => {CODE}-from-pstn

[{CODE}-from-pstn]
include => {CODE}-from-pstn-custom		; create this context in extensions_custom.conf to include customizations
include => {CODE}-ext-did
include => {CODE}-ext-did-post-custom
include => {CODE}-from-did-direct		; MODIFICATION (PL) for findmefollow if enabled, should be before ext-local
include => {CODE}-ext-did-catchall		; THIS MUST COME AFTER ext-did

;-------------------------------------------------------------------------------
; from-pstn-e164-us:
;
; The context is designed for providers who send calls in e164 format and is
; biased towards NPA calls, callerid and dialing rules. It will do the following:
;
;  DIDs in an NPA e164 format of +1NXXNXXXXXX will be converted to 10 digit DIDs
;
;  DIDs in any other format will be delivered as they are, including e164 non NPA
;  DIDs which means they will need the full format including the + in the inbound
;  route.
;
;  CallerID(number) presented in e164 NPA format will be trimmed to a 10 digit CID
;
;  CallerID(number) presented in e164 non-NPA (country code other than 1) will be
;  reformated from: +<CountryCode><Number> to 011<CountryCode><Number>
;
[{CODE}-from-pstn-e164-us]
exten => _+1NXXNXXXXXX/_+1NXXNXXXXXX,1,Set(CALLERID(number)=${CALLERID(number):2})
exten => _+1NXXNXXXXXX/_NXXNXXXXXX,2,Goto({CODE}-from-pstn,${EXTEN:2},1)
exten => _+1NXXNXXXXXX/_+X.,1,Set(CALLERID(number)=011${CALLERID(number):1})
exten => _+1NXXNXXXXXX/_011X.,n,Goto({CODE}-from-pstn,${EXTEN:2},1)
exten => _+1NXXNXXXXXX,1,Goto({CODE}-from-pstn,${EXTEN:2},1)
exten => _[0-9+]./_+1NXXNXXXXXX,1,Set(CALLERID(number)=${CALLERID(number):2})
exten => _[0-9+]./_NXXNXXXXXX,n,Goto({CODE}-from-pstn,${EXTEN},1)
exten => _[0-9+]./_+X.,1,Set(CALLERID(number)=011${CALLERID(number):1})
exten => _[0-9+]./_011X.,n,Goto({CODE}-from-pstn,${EXTEN},1)
exten => _[0-9+].,1,Goto({CODE}-from-pstn,${EXTEN},1)
exten => s/_+1NXXNXXXXXX,1,Set(CALLERID(number)=${CALLERID(number):2})
exten => s/_NXXNXXXXXX,n,Goto({CODE}-from-pstn,${EXTEN},1)
exten => s/_+X.,1,Set(CALLERID(number)=011${CALLERID(number):1})
exten => s/_011X.,n,Goto({CODE}-from-pstn,${EXTEN},1)
exten => s,1,Goto({CODE}-from-pstn,${EXTEN},1)
;-------------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; from-pstn-to-did
;
; The context is designed for providers who send the DID in the TO: SIP header
; only. The format of this header is:
;
; To: <sip:2125551212@172.31.74.25>
;
; So the DID must be extracted between the sip: and the @, which this does
;
[{CODE}-from-pstn-toheader]
exten => _.,1,Goto({CODE}-from-pstn,${CUT(CUT(SIP_HEADER(To),@,1),:,2)},1)
;-------------------------------------------------------------------------------


; MODIFICATION (PL)
;
; Required to assure that direct dids go to personal ring group before local extension.
; This could be auto-generated however I it is preferred to be put here and hard coded
; so that it can be modified if ext-local should take precedence in certain situations.
; will have to decide what to do later.
;
[{CODE}-from-did-direct]
include => {CODE}-ext-findmefollow
include => {CODE}-ext-local


; ############################################################################
; Macros [macro]
; ############################################################################

; Rings one or more extensions.  Handles things like call forwarding and DND
; We don't call dial directly for anything internal anymore.
; ARGS: $TIMER, $OPTIONS, $EXT1, $EXT2, $EXT3, ...
; Use a Macro call such as the following:
;  Macro(dial,$DIAL_TIMER,$DIAL_OPTIONS,$EXT1,$EXT2,$EXT3,...)
[macro-{CODE}-dial]
exten => s,1,GotoIf($["${MOHCLASS}" = ""]?dial)
exten => s,n,SetMusicOnHold(${MOHCLASS})
exten => s,n(dial),AGI(dialparties.agi,{CODE})
exten => s,n,NoOp(Returned from dialparties with no extensions to call and DIALSTATUS: ${DIALSTATUS})

exten => s,n+2(normdial),Dial(${ds})                               ; dialparties will set the priority to 10 if $ds is not null
exten => s,n,Set(DIALSTATUS=${IF($["${DIALSTATUS_CW}"!="" ]?${DIALSTATUS_CW}:${DIALSTATUS})})
exten => s,n,GosubIf($["${SCREEN}" != "" | "${DIALSTATUS}" = "ANSWER"]?${DIALSTATUS},1)

exten => s,20(huntdial),NoOp(Returned from dialparties with hunt groups to dial )
exten => s,n,Set(HuntLoop=0)
exten => s,n(a22),GotoIf($[${HuntMembers} >= 1]?a30)  ; if this is from rg-group, don't strip prefix
exten => s,n,NoOp(Returning there are no members left in the hunt group to ring)

; dialparties.agi has setup the dialstring for each hunt member in a variable labeled HuntMember0, HuntMember1 etc for each iteration
; and The total number in HuntMembers. So for each iteration, we will update the CALLTRACE Data.
;
exten => s,n+2(a30),Set(HuntMember=HuntMember${HuntLoop})
exten => s,n,GotoIf($[$["${CALLTRACE_HUNT}" != "" ] & $[$["${RingGroupMethod}" = "hunt" ] | $["${RingGroupMethod}" = "firstavailable"] | $["${RingGroupMethod}" = "firstnotonphone"]]]?a32:a35)

exten => s,n(a32),Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${HuntLoop} + 1])})
exten => s,n,Set(DB(CALLTRACE/{CODE}/${CT_EXTEN})=${CALLTRACE_HUNT})
exten => s,n,Goto(s,a42)

;Set Call Trace for each hunt member we are going to call "Memory groups have multiple members to set CALL TRACE For" hence the loop
;
exten => s,n(a35),GotoIf($[$["${CALLTRACE_HUNT}" != "" ] & $["${RingGroupMethod}" = "memoryhunt" ]]?a36:a50)
exten => s,n(a36),Set(CTLoop=0)
exten => s,n(a37),GotoIf($[${CTLoop} > ${HuntLoop}]?a42)  ; if this is from rg-group, don't strip prefix
exten => s,n,Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${CTLoop} + 1])})
exten => s,n,Set(DB(CALLTRACE/{CODE}/${CT_EXTEN})=${CALLTRACE_HUNT})
exten => s,n,Set(CTLoop=$[1 + ${CTLoop}])
exten => s,n,Goto(s,a37)

exten => s,n(a42),Dial(${${HuntMember}}${ds})
exten => s,n,GotoIf($["${DIALSTATUS}" = "ANSWER"]?ANSWER,1)
exten => s,n,Set(HuntLoop=$[1 + ${HuntLoop}])
exten => s,n,GotoIf($[$[$["foo${RingGroupMethod}" != "foofirstavailable"] & $["foo${RingGroupMethod}" != "foofirstnotonphone"]] | $["foo${DialStatus}" = "fooBUSY"]]?a46)
exten => s,n,Set(HuntMembers=0)
exten => s,n(a46),Set(HuntMembers=$[${HuntMembers} - 1])
exten => s,n,Goto(s,a22)

exten => s,n(a50),DBdel(CALLTRACE/{CODE}/${CT_EXTEN})
exten => s,n,Goto(s,a42)

; For call screening
exten => NOANSWER,1,Macro({CODE}-vm,${SCREEN_EXTEN},BUSY,${IVR_RETVM})
exten => NOANSWER,n,GotoIf($["${IVR_RETVM}" != "RETURN" | "${IVR_CONTEXT}" = ""]?bye)
exten => NOANSWER,n,Return
exten => NOANSWER,n(bye),Macro({CODE}-hangupcall)
exten => TORTURE,1,Goto(app-blackhole,musiconhold,1)
exten => TORTURE,n,Macro({CODE}-hangupcall)
exten => DONTCALL,1,Answer
exten => DONTCALL,n,Wait(1)
exten => DONTCALL,n,Zapateller()
exten => DONTCALL,n,Playback(ss-noservice)
exten => DONTCALL,n,Macro({CODE}-hangupcall)
exten => ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => ANSWER,n,Macro({CODE}-hangupcall,)

; make sure hungup calls go here so that proper cleanup occurs from call confirmed calls and the like
;
exten => h,1,Macro({CODE}-hangupcall)

; get the voicemail context for the user in ARG1
[macro-{CODE}-get-vmcontext]
exten => s,1,Set(VMCONTEXT=${DB(EXTUSER/{CODE}/${ARG1}/voicemail)})
exten => s,2,GotoIf($["foo${VMCONTEXT}" = "foo"]?200:300)
exten => s,200,Set(VMCONTEXT=default)
exten => s,300,NoOp()

; For some reason, if I don't run setCIDname, CALLERID(name) will be blank in my AGI
; ARGS: none
[macro-{CODE}-fixcid]
exten => s,1,Set(CALLERID(name)=${CALLERID(name)})

; Ring groups of phones
; ARGS: comma separated extension list
; 1 - Ring Group Strategy
; 2 - ringtimer
; 3 - prefix
; 4 - extension list
[macro-{CODE}-rg-group]
exten => s,1,Macro({CODE}-user-callerid,SKIPTTL) ; already called from ringgroup
exten => s,2,GotoIf($["${CALLERID(name):0:${LEN(${RGPREFIX})}}" != "${RGPREFIX}"]?4:3)  ; check for old prefix
exten => s,3,Set(CALLERID(name)=${CALLERID(name):${LEN(${RGPREFIX})}}) ; strip off old prefix
exten => s,4,Set(RGPREFIX=${ARG3})  ; set new prefix
exten => s,5,Set(CALLERID(name)=${RGPREFIX}${CALLERID(name)})  ; add prefix to callerid name
exten => s,6,Set(RecordMethod=Group)  ; set new prefix
exten => s,7,Macro({CODE}-record-enable,${MACRO_EXTEN},${RecordMethod})
exten => s,8,Set(RingGroupMethod=${ARG1})     ;
exten => s,9,Macro({CODE}-dial,${ARG2},${DIAL_OPTIONS},${ARG4})
exten => s,10,Set(RingGroupMethod='')     ;


;
; Outgoing channel(s) are busy ... inform the client
; but use noanswer features like ringgroups don't break by being answered
; just to play the message.
;
[macro-{CODE}-outisbusy]
exten => s,1,Progress
exten => s,n,Playback(all-circuits-busy-now,noanswer)
exten => s,n,Playback(pls-try-call-later,noanswer)
exten => s,n,Macro({CODE}-hangupcall)

; dialout and strip the prefix
[macro-{CODE}-dialout]
exten => s,1,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,2,GotoIf($["${ECID${CALLERID(number)}}" = ""]?5) 	;check for CID override for exten
exten => s,3,Set(CALLERID(all)=${ECID${CALLERID(number)}})
exten => s,4,Goto(7)
exten => s,5,GotoIf($["${OUTCID_${ARG1}}" = ""]?7) 		;check for CID override for trunk
exten => s,6,Set(CALLERID(all)=${OUTCID_${ARG1}})
exten => s,7,Set(length=${LEN(${DIAL_OUT_${ARG1}})})
exten => s,8,Dial(${OUT_${ARG1}}/${ARG2:${length}})
exten => s,9,Playtones(congestion)
exten => s,10,Congestion(5)
exten => s,109,Macro({CODE}-outisbusy)


; dialout using default OUT trunk - no prefix
[macro-{CODE}-dialout-default]
exten => s,1,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,2,Macro({CODE}-record-enable,${CALLERID(number)},OUT)
exten => s,3,Macro({CODE}-outbound-callerid,${ARG1})
exten => s,4,Dial(${OUT}/${ARG1})
exten => s,5,Playtones(congestion)
exten => s,6,Congestion(5)
exten => s,105,Macro({CODE}-outisbusy)

[macro-{CODE}-dialout-trunk-predial-hook]
; this macro intentionally left blank so it may be safely overwritten for any custom
; requirements that an installation may have.
;
; MACRO RETURN CODE: ${PREDIAL_HOOK_RET}
;                    if set to "BYPASS" then this trunk will be skipped
;
exten => s,1,MacroExit()

[macro-{CODE}-user-logon]
; check device type
;
exten => s,1,Set(DEVICETYPE=${DB(DEVICE/{CODE}/{CODE}_${CALLERID(number)}/type)})
exten => s,n,Answer()
exten => s,n,Wait(1)
exten => s,n,GotoIf($["${DEVICETYPE}" = "fixed"]?s-FIXED,1)
; get user's extension
;
exten => s,n,Set(EXTUSER=${ARG1})
exten => s,n,GotoIf($["${EXTUSER}" != ""]?gotpass)
exten => s,n(playagain),Read(EXTUSER,please-enter-your-extension-then-press-pound,,,4)
; get user's password and authenticate
;
exten => s,n,GotoIf($["${EXTUSER}" = ""]?s-MAXATTEMPTS,1)
exten => s,n(gotpass),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${EXTUSER}/password)}" = "0"]?s-NOUSER,1)
exten => s,n,Set(EXTPASS=${DB_RESULT})
exten => s,n,GotoIf($[${LEN(${EXTPASS})} = 0]?s-NOPASSWORD,1)
; do not continue if the user has already logged onto this device
;
exten => s,n,Set(DEVICEUSER=${DB(DEVICE/{CODE}/{CODE}_${CALLERID(number)}/user)})
exten => s,n,GotoIf($["${DEVICEUSER}" = "${EXTUSER}"]?s-ALREADYLOGGEDON,1)
exten => s,n,Authenticate(${EXTPASS})
exten => s,n,AGI(user_login_out.agi,{CODE},login,${CALLERID(number)},${EXTUSER})
exten => s,n,Playback(vm-goodbye)

exten => s-FIXED,1,NoOp(Device is FIXED and cannot be logged into)
exten => s-FIXED,n,Playback(ha/phone)
exten => s-FIXED,n,SayDigits(${CALLERID(number)})
exten => s-FIXED,n,Playback(is-curntly-unavail&vm-goodbye)
exten => s-FIXED,n,Hangup ;TODO should play msg indicated device cannot be logged into

exten => s-ALREADYLOGGEDON,1,NoOp(This device has already been logged into by this user)
exten => s-ALREADYLOGGEDON,n,Playback(vm-goodbye)
exten => s-ALREADYLOGGEDON,n,Hangup ;TODO should play msg indicated device is already logged into

exten => s-NOPASSWORD,1,NoOp(This extension does not exist or no password is set)
exten => s-NOPASSWORD,n,Playback(pbx-invalid)
exten => s-NOPASSWORD,n,Goto(s,playagain)

exten => s-MAXATTEMPTS,1,NoOp(Too many login attempts)
exten => s-MAXATTEMPTS,n,Playback(vm-goodbye)
exten => s-MAXATTEMPTS,n,Hangup

exten => s-NOUSER,1,NoOp(Invalid extension ${EXTUSER} entered)
exten => s-NOUSER,n,Playback(pbx-invalid)
exten => s-NOUSER,n,Goto(s,playagain)

[macro-{CODE}-user-logoff]
; check device type
;
exten => s,1,Set(DEVICETYPE=${DB(DEVICE/{CODE}/{CODE}_${CALLERID(number)}/type)})
exten => s,n,GotoIf($["${DEVICETYPE}" = "fixed"]?s-FIXED,1)
exten => s,n,AGI(user_login_out.agi,{CODE},logout,${CALLERID(number)})
exten => s,n(done),Playback(vm-goodbye)

exten => s-FIXED,1,NoOp(Device is FIXED and cannot be logged out of)
exten => s-FIXED,n,Playback(an-error-has-occured&vm-goodbye)
exten => s-FIXED,n,Hangup ;TODO should play msg indicated device cannot be logged into



; Privacy Manager Macro makes sure that any calls that don't pass the privacy manager are presented
; with congestion since there have been observed cases of the call continuing if not stopped with a
; congestion, and this provides a slightly more friendly 'sorry' message in case the user is
; legitimately trying to be cooperative.
;
; Note: the following options are configurable in privacy.conf:
;
;	maxretries = 3 ; default value, number of retries before failing
;	minlength = 10 ; default value, number of digits to be accepted as valid CID
;
[macro-{CODE}-privacy-mgr]
exten => s,1,Set(KEEPCID=${CALLERID(num)})
exten => s,n,GotoIf($["foo${CALLERID(num):0:1}"="foo+"]?CIDTEST2:CIDTEST1)
exten => s,n(CIDTEST1),Set(TESTCID=${MATH(1+${CALLERID(num)})})
exten => s,n,Goto(TESTRESULT)
exten => s,n(CIDTEST2),Set(TESTCID=${MATH(1+${CALLERID(num):1})})
exten => s,n(TESTRESULT),GotoIf($["foo${TESTCID}"="foo"]?CLEARCID:PRIVMGR)
exten => s,n(CLEARCID),Set(CALLERID(num)=)
exten => s,n(PRIVMGR),PrivacyManager(${ARG1},${ARG2})
exten => s,n,GotoIf($["${PRIVACYMGRSTATUS}"="FAILED"]?fail)
exten => s,n,GosubIf($["${CALLED_BLACKLIST}" = "1"]?app-blacklist-check,s,1)
exten => s,n,SetCallerPres(allowed_passed_screen); stop gap until app_privacy.c clears unavailable bit
exten => s,PRIVMGR+101(fail),Noop(STATUS: ${PRIVACYMGRSTATUS} CID: ${CALLERID(num)} ${CALLERID(name)} CALLPRES: ${CALLLINGPRES})
exten => s,n,Playback(sorry-youre-having-problems)
exten => s,n,Playback(goodbye)
exten => s,n,Playtones(congestion)
exten => s,n,Congestion(5)
exten => h,1,Hangup



; Text-To-Speech related macros
; These all follow common actions.  First try to playback a file "tts/custom-md5"
; where "md5" is the md5() of whatever is going to be played. If that doesn't exist,
; try to playback using macro-tts-sayXXXXX (where XXXXX is text/digits/etc, same as
; the macro below). If that macro exits with MACRO_OFFSET=100, then it's done,
; otherwise, fallback to the default asterisk method.
;
; say text is purely for text-to-speech, there is no fallback
[macro-{CODE}-saytext]
exten => s,1,Noop(Trying custom SayText playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-saytext. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro({CODE}-tts-saytext,${ARG1},${ARG2},${ARG3})
exten => s,n,Noop(No text-to-speech handler for SayText, cannot say "${ARG1}")
exten => s,n,Goto(done)
exten => s,tts+101,Noop(tts handled saytext)

; say name is for saying names typically, but fallsback to using SayAlpha
; (saying the word letter-by-letter)
[macro-{CODE}-sayname]
exten => s,1,Noop(Trying custom SayName playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-sayalpha. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro({CODE}-tts-sayalpha,${ARG1},${ARG2},${ARG3})
exten => s,n,SayAlpha(${ARG1})
exten => s,n,Goto(done)
exten => s,tts+101,Noop(tts handled sayname)

; Say number is for saying numbers (eg "one thousand forty six")
[macro-{CODE}-saynumber]
exten => s,1,Noop(Trying custom SayNumber playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-saynumber. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro({CODE}-tts-saynumber,${ARG1},${ARG2},${ARG3})
exten => s,n,SayNumber(${ARG1})
exten => s,n,Goto(done)
exten => s,tts+101,Noop(tts handled saynumber)

; Say digits is for saying digits one-by-one (eg, "one zero four six")
[{CODE}-macro-saydigits]
exten => s,1,Noop(Trying custom SayDigits playback for "${ARG1}")
exten => s,n,Playback(tts/custom-${MD5(${ARG1})})
exten => s,n,GotoIf($["${PLAYBACKSTATUS}"="SUCCESS"]?done)
; call tts-saydigits. This should set MACRO_OFFSET=101 if it was successful
exten => s,n(tts),Macro({CODE}-tts-saydigits,${ARG1},${ARG2},${ARG3})
exten => s,n,SayDigits(${ARG1})
exten => s,n,Goto(done)


;
; ############################################################################
; Inbound Contexts [from]
; ############################################################################

[{CODE}-from-sip-external]
; Yes. This is _really_ meant to be _. - I know asterisk whines about it, but
; I do know what I'm doing. This is correct.
exten => _.,1,NoOp(Received incoming SIP connection from unknown peer to ${EXTEN})
exten => _.,n,Set(DID=${IF($["${EXTEN:1:2}"=""]?s:${EXTEN})})
exten => _.,n,Goto(s,1)
exten => s,1,GotoIf($["${ALLOW_SIP_ANON}"="yes"]?checklang:noanonymous)
exten => s,n(checklang),GotoIf($["${SIPLANG}"!=""]?setlanguage:{CODE}-from-trunk,${DID},1)
exten => s,n(setlanguage),Set(CHANNEL(language)=${SIPLANG})
exten => s,n,Goto({CODE}-from-trunk,${DID},1)
exten => s,n(noanonymous),Set(TIMEOUT(absolute)=15)
exten => s,n,Answer
exten => s,n,Wait(2)
exten => s,n,Playback(ss-noservice)
exten => s,n,Playtones(congestion)
exten => s,n,Congestion(5)
exten => h,1,Hangup
exten => i,1,Hangup
exten => t,1,Hangup

[{CODE}-from-internal-xfer]
; applications are now mostly all found in from-internal-additional in _custom.conf
include => {CODE}-from-internal-custom
include => {CODE}-parkedcalls

; MODIFIED (PL)
;
; Currently the include for findmefollow is being auto-generated before ext-local which is the desired behavior.
; However, I haven't been able to do anything that I know of to force this. We need to determine if it should
; be hardcoded into here to make sure it doesn't change with some configuration. For now I will leave it out
; until we can discuss this.
;
include => {CODE}-ext-local-confirm
include => {CODE}-findmefollow-ringallv2
include => {CODE}-from-internal-additional
; This causes grief with '#' transfers, commenting out for the moment.
; include => bad-number
exten => s,1,Macro({CODE}-hangupcall)
exten => h,1,Macro({CODE}-hangupcall)

[{CODE}-from-internal]
include => {CODE}-from-internal-xfer
include => {CODE}-bad-number

;------------------------------------------------------------------------
; [macro-setmusic]
;------------------------------------------------------------------------
; CONTEXT:      macro-setmusic
; PURPOSE:      to turn off moh on routes where it is not desired
;
;------------------------------------------------------------------------
[macro-{CODE}-setmusic]
exten => s,1,NoOp(Setting Outbound Route MoH To: ${ARG1})
exten => s,2,Set(CHANNEL(musicclass)=${ARG1}) ; this won't work in 1.2 anymore, could fix in auto-generate if we wanted...
;------------------------------------------------------------------------

; ##########################################
; ## Ring Groups with Confirmation macros ##
; ##########################################
; Used by followme and ringgroups

;------------------------------------------------------------------------
; [macro-dial-confirm]
;------------------------------------------------------------------------
; This has now been incorporated into dialparties. It still only works with ringall
; and ringall-prim strategies. Have not investigated why it doesn't work with
; hunt and memory hunt.
;
;------------------------------------------------------------------------
[macro-{CODE}-dial-confirm]
; This was written to make it easy to use macro-dial-confirm instead of macro-dial in generated dialplans.
; This takes the same parameters, with an additional parameter of the ring group Number
; ARG1 is the timeout
; ARG2 is the DIAL_OPTIONS
; ARG3 is a list of xtns to call - 203-222-240-123123123#-211
; ARG4 is the ring group number

; This sets a unique value to indicate that the channel is ringing. This is used for warning slow
; users that the call has already been picked up.
;
exten => s,1,Set(DB(RG/{CODE}/${ARG4}/${CHANNEL})=RINGING)

; We need to keep that channel variable, because it'll change when we do this dial, so set it to
; fallthrough to every sibling.
;
exten => s,n,Set(__UNIQCHAN=${CHANNEL})

; The calling ringgroup should have set RingGroupMethod appropriately. We need to set two
; additional parameters:
;
; USE_CONFIRMATION, RINGGROUP_INDEX
;
; These are passed to inform dialparties to place external calls through the [grps] context
;
exten => s,n,Set(USE_CONFIRMATION=TRUE)
exten => s,n,Set(RINGGROUP_INDEX=${ARG4})
exten => s,n,Set(ARG4=) ; otherwise it gets passed to dialparties.agi which processes it (prob bug)

exten => s,n,Macro({CODE}-dial,${ARG1},${ARG2},${ARG3})

; delete the variable, if we are here, we are done trying to dial and it may have been left around
;
exten => s,n,Noop(DELETE KEY: RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL}: ${DB_DELETE(RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL})})
exten => s,n,Set(USE_CONFIRMATION=)
exten => s,n,Set(RINGGROUP_INDEX=)
;------------------------------------------------------------------------


;------------------------------------------------------------------------
; [ext-local-confirm]
;------------------------------------------------------------------------
; If call confirm is being used in a ringgroup, then calls that do not require confirmation are sent
; to this extension instead of straight to the device.
;
; The sole purpose of sending them here is to make sure we run Macro(auto-confirm) if this
; extension answers the line. This takes care of clearing the database key that is used to inform
; other potential late comers that the extension has been answered by someone else.
;
; ALERT_INFO is deprecated in Asterisk 1.4 but still used throughout the FreePBX dialplan and
; usually set by dialparties.agi. This allows inheritance. Since no dialparties.agi here, set the
; header if it is set.
;
;------------------------------------------------------------------------
[{CODE}-ext-local-confirm]
exten => _LC-.,1,Noop(IN ext-local-confirm with - RT: ${RT}, RG_IDX: ${RG_IDX})
exten => _LC-.,n,GotoIf($["x${ALERT_INFO}"="x"]?godial)
exten => _LC-.,n,SIPAddHeader(Alert-Info: ${ALERT_INFO})
exten => _LC-.,n(godial),dial(${DB(DEVICE/{CODE}/{CODE}_${EXTEN:3}/dial)},${RT},M({CODE}-auto-confirm^${RG_IDX})${DIAL_OPTIONS})

;------------------------------------------------------------------------
; [findmefollow-ringallv2]
;------------------------------------------------------------------------
; This context, to be included in from-internal, implements the PreRing part of findmefollow
; as well as the GroupRing part. It also communicates between the two so that if DND is set
; on the primary extension, and mastermode is enabled, then the other extensions will not ring
;
;------------------------------------------------------------------------
[{CODE}-findmefollow-ringallv2]
exten => _FMPR-.,1,Noop(In FMPR ${FMGRP} with ${EXTEN:5})
exten => _FMPR-.,n,Set(RingGroupMethod=)
exten => _FMPR-.,n,Set(USE_CONFIRMATION=)
exten => _FMPR-.,n,Set(RINGGROUP_INDEX=)
exten => _FMPR-.,n,Macro({CODE}-simple-dial,${EXTEN:5},${FMREALPRERING})
exten => _FMPR-.,n,GotoIf($["${DIALSTATUS}" != "BUSY"]?nodnd)
exten => _FMPR-.,n,Set(DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})=DND)
exten => _FMPR-.,n(nodnd),Noop(Ending FMPR ${FMGRP} with ${EXTEN:5} and dialstatus ${DIALSTATUS})
exten => _FMPR-.,n,Hangup()

exten => _FMGL-.,1,Noop(In FMGL ${FMGRP} with ${EXTEN:5})
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,Wait(1)
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,Wait(1)
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,Wait(${FMPRERING})
exten => _FMGL-.,n,GotoIf($["${DB(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})}" = "DND"]?dodnd)
exten => _FMGL-.,n,DBDel(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})
exten => _FMGL-.,n(dodial),Macro({CODE}-dial,${FMGRPTIME},${DIAL_OPTIONS},${EXTEN:5})
exten => _FMGL-.,n,Noop(Ending FMGL ${FMGRP} with ${EXTEN:5} and dialstatus ${DIALSTATUS})
exten => _FMGL-.,n,Hangup()
exten => _FMGL-.,n+10(dodnd),DBDel(FM/DND/{CODE}/${FMGRP}/${FMUNIQUE})
exten => _FMGL-.,n,GotoIf($["${FMPRIME}" = "FALSE"]?dodial)
exten => _FMGL-.,n,Noop(Got DND in FMGL ${FMGRP} with ${EXTEN:5} in ${RingGroupMethod} mode, aborting)
exten => _FMGL-.,n,Hangup()

;------------------------------------------------------------------------
; [block-cf]
;------------------------------------------------------------------------
; This context is set as a target with FORWARD_CONTEXT when Call Forwarding is set to be
; ignored in a ringgroup or other features that may take advantage of this. Server side
; CF is done in dialparties.agi but if a client device forwards a call, it will be caught
; and blocked here.
;------------------------------------------------------------------------
[{CODE}-block-cf]
exten => _X.,1,Noop(Blocking callforward to ${EXTEN} because CF is blocked)
exten => _X.,n,Hangup()

;------------------------------------------------------------------------


;this is where parked calls go if they time-out.  Should probably re-ring
[{CODE}-default]
include => {CODE}-ext-local
exten => s,1,Playback(vm-goodbye)
exten => s,2,Macro({CODE}-hangupcall)


[macro-{CODE}-agent-add]
include => macro-{CODE}-agent-add-custom
exten => s,1,Wait(1)
exten => s,n,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,n(a3),Read(CALLBACKNUM,agent-login,,,,)
exten => s,n,GotoIf($[${LEN(${CALLBACKNUM})}=0]?a5:a7)
exten => s,n(a5),Set(CALLBACKNUM=${IF($[${LEN(${EXTUSER})}=0]?${CALLERID(number)}:${EXTUSER})})
exten => s,n,Set(THISDEVICE=${DB(DEVICE/{CODE}/${REALCALLERIDNUM}/dial)})
exten => s,n,GotoIf($["${CALLBACKNUM}" = ""]?a3)
exten => s,n(a7),GotoIf($["${CALLBACKNUM}" = "${ARG1}"]?invalid)
exten => s,n,GotoIf($["${ARG3}" = "EXTEN" & ${DB_EXISTS(EXTUSER/{CODE}/${CALLBACKNUM}/cidname)} = 0]?invalid)
exten => s,n,GotoIf($["${DB(QPENALTY/{CODE}/${ARG1}/dynmemberonly)}" = "yes" & ${DB_EXISTS(QPENALTY/{CODE}/${ARG1}/agents/${CALLBACKNUM})} != 1]?invalid)
exten => s,n,ExecIf($["${QREGEX}" != ""]?GotoIf($["${REGEX("${QREGEX}" ${CALLBACKNUM})}" = "0"]?invalid))
exten => s,n,ExecIf($["${ARG2}" != ""]?Authenticate(${ARG2}))
; addQueuMember(cola,inferface añadir cola,penalty,option esto vacio,nombre del miembro solo descripcion,interface a monitorear)
exten => s,n,ExecIf($[${DB_EXISTS(EXTUSER/{CODE}/${CALLBACKNUM}/cidname)} = 1]?AddQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-queue/n,${DB(QPENALTY/{CODE}/${ARG1}/agents/${CALLBACKNUM})},,${DB(EXTUSER/{CODE}/${CALLBACKNUM}/cidname)},hint:${CALLBACKNUM}@{CODE}-ext-local))
exten => s,n,ExecIf($[${DB_EXISTS(EXTUSER/{CODE}/${CALLBACKNUM}/cidname)} = 0]?AddQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-queue/n,${DB(QPENALTY/{CODE}/${ARG1}/agents/${CALLBACKNUM})}))
exten => s,n,UserEvent(Agentlogin,Agent: ${CALLBACKNUM})
exten => s,n,Wait(1)
exten => s,n,Playback(agent-loginok&with&extension)
exten => s,n,SayDigits(${CALLBACKNUM})
exten => s,n,Hangup
exten => s,n,MacroExit()
exten => s,n(invalid),Playback(pbx-invalid)
exten => s,n,Goto(a3)

; end of [macro-{CODE}-agent-add]


[macro-{CODE}-agent-del]
include => macro-{CODE}-agent-del-custom
exten => s,1,Wait(1)
exten => s,n,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,n(a3),Read(CALLBACKNUM,agent-logoff,,,,)
exten => s,n,GotoIf($[${LEN(${CALLBACKNUM})}=0]?a5:a7)
exten => s,n(a5),Set(CALLBACKNUM=${IF($[${LEN(${EXTUSER})}=0]?${CALLERID(number)}:${EXTUSER})})
exten => s,n,GotoIf($["${CALLBACKNUM}" = ""]?a3)
exten => s,n(a7),RemoveQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-queue/n)
exten => s,n,RemoveQueueMember(${ARG1},Local/${CALLBACKNUM}@{CODE}-from-internal/n)
exten => s,n,UserEvent(RefreshQueue)
exten => s,n,Wait(1)
exten => s,n,Playback(agent-loggedoff)
exten => s,n,Hangup

; end of [macro-{CODE}-agent-del]

; para buscar un numero asignado a marcacion rapida
; ARG1 -> posicion de maracado rapido
; ARG2 -> usuario que tiene la asignacion (puede ser vacio)
[macro-{CODE}-speeddial-lookup]
include => macro-{CODE}-speeddial-lookup-custom
exten => s,1,GotoIf($["${ARG2}"=""]]?lookupsys)
exten => s,n,Set(SPEEDDIALNUMBER=)
exten => s,n(lookupuser),Set(SPEEDDIALNUMBER=${DB(EXTUSER/{CODE}/${ARG2}/speeddials/${ARG1})})
exten => s,n,GotoIf($["${SPEEDDIALNUMBER}"=""]?lookupsys)
exten => s,n,Noop(Found speeddial ${ARG1} for user ${ARG2}: ${SPEEDDIALNUMBER})
exten => s,n,Goto(end)
exten => s,lookupuser+101(lookupsys),Set(SPEEDDIALNUMBER=${DB(sysspeeddials/{CODE}/${ARG1})})
exten => s,n,GotoIf($["${SPEEDDIALNUMBER}"=""]?failed)
exten => s,n,Noop(Found system speeddial ${ARG1}: ${SPEEDDIALNUMBER})
exten => s,n,Goto(end)
exten => s,lookupsys+101(failed),Noop(No system or user speeddial found)
exten => s,n(end),Noop(End of Speeddial-lookup)

; end of [macro-speeddial-lookup]


[macro-{CODE}-outisbusy]
include => {CODE}-macro-outisbusy-custom
exten => s,1,Progress
exten => s,n,GotoIf($["${EMERGENCYROUTE}" = "YES"]?emergency,1)
exten => s,n,GotoIf($["${INTRACOMPANYROUTE}" = "YES"]?intracompany,1)
exten => s,n,Playback(all-circuits-busy-now&pls-try-call-later, noanswer)
exten => s,n,Congestion(20)
exten => s,n,Hangup
exten => intracompany,1,Playback(all-circuits-busy-now&pls-try-call-later, noanswer)
exten => intracompany,n,Congestion(20)
exten => intracompany,n,Hangup
exten => emergency,1,Playback(all-circuits-busy-now&pls-try-call-later)
exten => emergency,n,Congestion(20)
exten => emergency,n,Hangup

; end of [macro-{CODE}-outisbusy]


[macro-{CODE}-record-enable]
include => macro-{CODE}-record-enable-custom
exten => s,1,GotoIf($["${RECORDING_STATE}"!="DISABLED"]?start)
exten => s,n(disabled),MacroExit()
exten => s,n(start),GotoIf($["${BLINDTRANSFER}" = ""]?check)
exten => s,n,ResetCDR(w)
exten => s,n,StopMixMonitor()
exten => s,n(check),ExecIf($["${ARG1}"=""]?MacroExit())
exten => s,n,GotoIf($["${ARG2}"="Group"]?Group:OUT)
exten => s,n(Group),Set(LOOPCNT=${FIELDQTY(ARG1,-)})
exten => s,n,Set(ITER=1)
exten => s,n(begin),GotoIf($["${CUT(DB(EXTUSER/{CODE}/${CUT(ARG1,-,${ITER})}/recording),=,3)}" != "Always"]?continue)
exten => s,n,Set(TEXTEN=${CUT(ARG1,-,${ITER})})
exten => s,n,Noop(Recording enable for ${TEXTEN})
exten => s,n,Set({CODE}_CALLFILENAME=g${TEXTEN}-${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,Goto(record)
exten => s,n(continue),Set(ITER=$[${ITER}+1])
exten => s,n,GotoIf($[${ITER}<=${LOOPCNT}]?begin)
exten => s,n(OUT),GotoIf($["${ARG2}"="IN"]?IN)
exten => s,n,ExecIf($["${CUT(DB(EXTUSER/{CODE}/${ARG1}/recording),\\\|,1):4}" != "Always"]?MacroExit())
exten => s,n,Noop(Recording enable for ${ARG1})
exten => s,n,Set({CODE}_CALLFILENAME=OUT${ARG1}-${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,Goto(record)
exten => s,n(IN),ExecIf($["${CUT(DB(EXTUSER/{CODE}/${ARG1}/recording),\\\|,2):3}" != "Always"]?MacroExit())
exten => s,n,Noop(Recording enable for ${ARG1})
exten => s,n,Set({CODE}_CALLFILENAME=${STRFTIME(${EPOCH},,%Y%m%d-%H%M%S)}-${UNIQUEID})
exten => s,n,ExecIf($["${{CODE}_MIXMON_DIR}"=""]?Set({CODE}_MIXMON_DIR=${MIXMON_DIR}{DOMAIN}/))
exten => s,n(record),MixMonitor(${{CODE}_MIXMON_DIR}${{CODE}_CALLFILENAME}.${{CODE}_MIXMON_FORMAT},,${{CODE}_MIXMON_POST})
exten => s,n,Set(CDR(userfield)=audio:${{CODE}_CALLFILENAME}.${{CODE}_MIXMON_FORMAT})
exten => s,n,MacroExit()


[{CODE}-ext-did-catchall]
include => ext-did-catchall-custom
exten => s,1,Noop(No DID or CID Match)
exten => s,n(a2),Answer
exten => s,n,Wait(2)
exten => s,n,Playback(ss-noservice)
exten => s,n,SayAlpha(${FROM_DID})
exten => s,n,Hangup
exten => _.,1,Set(__FROM_DID=${EXTEN})
exten => _.,n,Noop(Received an unknown call with DID set to ${EXTEN})
exten => _.,n,Goto(s,a2)
exten => h,1,Hangup

; end of [ext-did-catchall]


[{CODE}-app-blackhole]
include => {CODE}-app-blackhole-custom
exten => hangup,1,Noop(Blackhole Dest: Hangup)
exten => hangup,n,Hangup
exten => zapateller,1,Noop(Blackhole Dest: Play SIT Tone)
exten => zapateller,n,Answer
exten => zapateller,n,Zapateller()
exten => musiconhold,1,Noop(Blackhole Dest: Put caller on hold forever)
exten => musiconhold,n,Answer
exten => musiconhold,n,MusicOnHold()
exten => congestion,1,Noop(Blackhole Dest: Congestion)
exten => congestion,n,Answer
exten => congestion,n,Playtones(congestion)
exten => congestion,n,Congestion(20)
exten => congestion,n,Hangup
exten => busy,1,Noop(Blackhole Dest: Busy)
exten => busy,n,Answer
exten => busy,n,Playtones(busy)
exten => busy,n,Busy(20)
exten => busy,n,Hangup
exten => ring,1,Noop(Blackhole Dest: Ring)
exten => ring,n,Answer
exten => ring,n,Playtones(ring)
exten => ring,n,Wait(300)
exten => ring,n,Hangup

; end of [{CODE}-app-blackhole]


[{CODE}-bad-number]
include => {CODE}-bad-number-custom
exten => _X.,1,ResetCDR()
exten => _X.,n,NoCDR()
exten => _X.,n,Progress
exten => _X.,n,Wait(1)
exten => _X.,n,Progress
exten => _X.,n,Playback(silence/1&cannot-complete-as-dialed&check-number-dial-again,noanswer)
exten => _X.,n,Wait(1)
exten => _X.,n,Congestion(20)
exten => _X.,n,Hangup

; end of [{CODE}-bad-number]


;------------------------------------------------------------------------
; [macro-confirm]
;------------------------------------------------------------------------
; CONTEXT:      macro-confirm
; PURPOSE:      added default message if none supplied
;
; Follom-Me and Ringgroups provide an option to supply a message to be
; played as part of the confirmation. These changes have added a default
; message if none is supplied.
;
;------------------------------------------------------------------------
[macro-{CODE}-confirm]
include => macro-{CODE}-confirm-custom
exten => s,1,Set(LOOPCOUNT=0)
exten => s,n,Set(__MACRO_RESULT=ABORT)
exten => s,n,Set(MSG1=${IF($["foo${ARG1}" != "foo"]?${ARG1}:"incoming-call-1-accept-2-decline")})
exten => s,n(start),Background(${MSG1},m,${CHANNEL(language)},macro-confirm)
exten => s,n,Read(INPUT,,1,,,4)
exten => s,n,GotoIf($[${LEN(${INPUT})} > 0]?${INPUT},1:t,1)
exten => 1,1,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1)
exten => 1,n,Noop(Deleting: RG/{CODE}/${ARG3}/${UNIQCHAN} ${DB_DELETE(RG/{CODE}/${ARG3}/${UNIQCHAN})})
exten => 1,n,Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})
exten => 1,n,Set(__MACRO_RESULT=)
exten => 1,n(exitopt1),MacroExit()
exten => 2,1,Goto(noanswer,1)
exten => 3,1,SayDigits(${CALLCONFIRMCID})
exten => 3,n,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1:s,start)
exten => t,1,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1)
exten => t,n,Set(LOOPCOUNT=$[ ${LOOPCOUNT} + 1 ])
exten => t,n,GotoIf($[ ${LOOPCOUNT} < 5 ]?s,start:noanswer,1)
exten => _X,1,Background(invalid,m,${CHANNEL(language)},macro-confirm)
exten => _X,n,GotoIf($["${DB_EXISTS(RG/{CODE}/${ARG3}/${UNIQCHAN})}" = "0"]?toolate,1)
exten => _X,n,Set(LOOPCOUNT=$[ ${LOOPCOUNT} + 1 ])
exten => _X,n,GotoIf($[ ${LOOPCOUNT} < 5 ]?s,start:noanswer,1)
exten => noanswer,1,Set(__MACRO_RESULT=ABORT)
exten => noanswer,n(exitnoanswer),MacroExit()
exten => toolate,1,Set(MSG2=${IF($["foo${ARG2}" != "foo"]?${ARG2}:"incoming-call-no-longer-avail")})
exten => toolate,n,Playback(${MSG2})
exten => toolate,n,Set(__MACRO_RESULT=ABORT)
exten => toolate,n(exittoolate),MacroExit()
exten => h,1,Macro(hangupcall,)

; end of [{CODE}-macro-confirm]


;------------------------------------------------------------------------
; [macro-auto-confirm]
;------------------------------------------------------------------------
; This macro is called from ext-local-confirm to auto-confirm a call so that other extensions
; are aware that the call has been answered.
;
;------------------------------------------------------------------------
[macro-{CODE}-auto-confirm]
include => macro-{CODE}-auto-confirm-custom
exten => s,1,Set(__MACRO_RESULT=)
exten => s,n,Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})
exten => s,n,Noop(Deleting: RG/{CODE}/${ARG1}/${UNIQCHAN} ${DB_DELETE(RG/{CODE}/${ARG1}/${UNIQCHAN})})

; end of [macro-{CODE}-auto-confirm]


;------------------------------------------------------------------------
; [macro-auto-blkvm]
;------------------------------------------------------------------------
; This macro is called for any extension dialed form a queue, ringgroup
; or followme, so that the answering extension can clear the voicemail block
; override allow subsequent transfers to properly operate.
;
;------------------------------------------------------------------------
[macro-{CODE}-auto-blkvm]
include => macro-{CODE}-auto-blkvm-custom
exten => s,1,Set(__MACRO_RESULT=)
exten => s,n,Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})

; end of [macro-{CODE}-auto-blkvm]


;------------------------------------------------------------------------
; [sub-pincheck]
;------------------------------------------------------------------------
; This subroutine checks the pincode and then resets the CDR from that point
; if the pincode passes. This way the billsec and duration fields are set
; properly for pin dialing.
;
; ${ARG3} is the pincode if this was called, used by dialout-trunk, dialout-enum
; and dialout-dundi
;
;------------------------------------------------------------------------
[{CODE}-sub-pincheck]
include => {CODE}-sub-pincheck-custom
exten => s,1,Authenticate(${ARG3},)
exten => s,n,ResetCDR()
exten => s,n,Return()
; end of [{CODE}-sub-pincheck]

; se creo para verificar que llamadas realizadas de una compañia a otra compañia
; que pertenzcan al mismo servidor no salgan por la pstn
[{CODE}-salida-check]
exten => s,1(check),Set(REDIRECCIONAR=${IF($["${DB_EXISTS(NUMERO/${OUTNUM})}"="1" & "${DB_RESULT}"!="{CODE}"]?1:0)})
exten => s,n,GotoIf($[${REDIRECCIONAR} = 1]?salida-check,s,fin)
exten => s,n,Dial(Local/${OUTNUM}@${DB_RESULT}-from-analog,300,${DIAL_TRUNK_OPTIONS})
exten => s,n(fin),Return()
; end of [app-blacklist-check] 


; dialout using a trunk, using pattern matching (don't strip any prefix)
; arg1 = trunk number, arg2 = number, arg3 = route password
;
; MODIFIED (PL)
;
; Modified both Dial() commands to include the new TRUNK_OPTIONS from the general
; screen of AMP

[macro-{CODE}-dialout-trunk]
include => macro-{CODE}-dialout-trunk-custom
exten => s,1,Set(DIAL_TRUNK=${ARG1})
exten => s,n,GosubIf($[$["${ARG3}" != ""] & $["${DB(EXTUSER/{CODE}/${EXTUSER}/pinless)}" != "NOPASSWD"]]?sub-pincheck,s,1)
exten => s,n,GotoIf($["x${OUTDISABLE_${DIAL_TRUNK}}" = "xon"]?disabletrunk,1)
exten => s,n,Set(DIAL_NUMBER=${ARG2})
exten => s,n,Set(DIAL_TRUNK_OPTIONS=${DIAL_OPTIONS})
exten => s,n,Set(OUTBOUND_GROUP=OUT_${DIAL_TRUNK})
exten => s,n,GotoIf($["${OUTMAXCHANS_${DIAL_TRUNK}}foo" = "foo"]?nomax)
exten => s,n,GotoIf($[ ${GROUP_COUNT(OUT_${DIAL_TRUNK})} >= ${OUTMAXCHANS_${DIAL_TRUNK}} ]?chanfull)
exten => s,n(nomax),GotoIf($["${INTRACOMPANYROUTE}" = "YES"]?skipoutcid)
exten => s,n,Set(DIAL_TRUNK_OPTIONS=${TRUNK_OPTIONS})
exten => s,n,Macro({CODE}-outbound-callerid,${DIAL_TRUNK})
exten => s,n(skipoutcid),GosubIf($["${PREFIX_TRUNK_${DIAL_TRUNK}}" != ""]?sub-flp-${DIAL_TRUNK},s,1)
exten => s,n,Set(OUTNUM=${OUTPREFIX_${DIAL_TRUNK}}${DIAL_NUMBER})
exten => s,n,Set(custom=${CUT(OUT_${DIAL_TRUNK},:,1)})
exten => s,n,ExecIf($[$["${MOHCLASS}" != "default"] & $["${MOHCLASS}" != ""]]?Set(DIAL_TRUNK_OPTIONS=M(setmusic^${MOHCLASS})${DIAL_TRUNK_OPTIONS}))
exten => s,n(gocall),Macro({CODE}-dialout-trunk-predial-hook,)
exten => s,n,GotoIf($["${PREDIAL_HOOK_RET}" = "BYPASS"]?bypass,1)
exten => s,n,GotoIf($["${custom}" = "AMP"]?customtrunk)
exten => s,n,GosubIf($[${OUT_${DIAL_TRUNK}:0:4}=DHADI]?{CODE}-salida-check,s,1)
exten => s,n,Dial(${OUT_${DIAL_TRUNK}}/${OUTNUM},300,${DIAL_TRUNK_OPTIONS})
exten => s,n,Noop(Dial failed for some reason with DIALSTATUS = ${DIALSTATUS} and HANGUPCAUSE = ${HANGUPCAUSE})
exten => s,n,Goto(s-${DIALSTATUS},1)
exten => s,n(customtrunk),Set(pre_num=${CUT(OUT_${DIAL_TRUNK},$,1)})
exten => s,n,Set(the_num=${CUT(OUT_${DIAL_TRUNK},$,2)})
exten => s,n,Set(post_num=${CUT(OUT_${DIAL_TRUNK},$,3)})
exten => s,n,GotoIf($["${the_num}" = "OUTNUM"]?outnum:skipoutnum)
exten => s,n(outnum),Set(the_num=${OUTNUM})
exten => s,n(skipoutnum),Dial(${pre_num:4}${the_num}${post_num},300,${DIAL_TRUNK_OPTIONS})
exten => s,n,Noop(Dial failed for some reason with DIALSTATUS = ${DIALSTATUS} and HANGUPCAUSE = ${HANGUPCAUSE})
exten => s,n,Goto(s-${DIALSTATUS},1)
exten => s,n(chanfull),Noop(max channels used up)
exten => s-BUSY,1,Noop(Dial failed due to trunk reporting BUSY - giving up)
exten => s-BUSY,n,Playtones(busy)
exten => s-BUSY,n,Busy(20)
exten => s-ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => s-ANSWER,n,Macro({CODE}-hangupcall,)
exten => s-NOANSWER,1,Noop(Dial failed due to trunk reporting NOANSWER - giving up)
exten => s-NOANSWER,n,Progress
exten => s-NOANSWER,n,Playback(number-not-answering,noanswer)
exten => s-NOANSWER,n,Congestion(20)
exten => s-INVALIDNMBR,1,Noop(Dial failed due to trunk reporting Address Incomplete - giving up)
exten => s-INVALIDNMBR,n,Progress
exten => s-INVALIDNMBR,n,Playback(ss-noservice,noanswer)
exten => s-INVALIDNMBR,n,Busy(20)
exten => s-CHANGED,1,Noop(Dial failed due to trunk reporting Number Changed - giving up)
exten => s-CHANGED,n,Playtones(busy)
exten => s-CHANGED,n,Busy(20)
exten => _s-.,1,Set(RC=${IF($[${ISNULL(${HANGUPCAUSE})}]?0:${HANGUPCAUSE})})
exten => _s-.,n,Goto(${RC},1)
exten => 17,1,Goto(s-BUSY,1)
exten => 18,1,Goto(s-NOANSWER,1)
exten => 22,1,Goto(s-CHANGED,1)
exten => 23,1,Goto(s-CHANGED,1)
exten => 28,1,Goto(s-INVALIDNMBR,1)
exten => _X,1,Goto(continue,1)
exten => _X.,1,Goto(continue,1)
exten => continue,1,GotoIf($["${OUTFAIL_${ARG1}}" = ""]?noreport)
exten => continue,n,AGI(${OUTFAIL_${ARG1}})
exten => continue,n(noreport),Noop(TRUNK Dial failed due to ${DIALSTATUS} HANGUPCAUSE: ${HANGUPCAUSE} - failing through to other trunks)
exten => continue,n,Set(CALLERID(number)=${EXTUSER})
exten => disabletrunk,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} DISABLED - falling through to next trunk)
exten => bypass,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} BYPASSING because dialout-trunk-predial-hook)
exten => h,1,Macro(hangupcall,)

; end of [macro-{CODE}-dialout-trunk]


[macro-{CODE}-dialout-dundi]
include => macro-{CODE}-dialout-dundi-custom
exten => s,1,Set(DIAL_TRUNK=${ARG1})
exten => s,n,GosubIf($[$["${ARG3}" != ""] & $["${DB(EXTUSER/{CODE}/${EXTUSER}/pinless)}" != "NOPASSWD"]]?sub-pincheck,s,1)
exten => s,n,GotoIf($["x${OUTDISABLE_${DIAL_TRUNK}}" = "xon"]?disabletrunk,1)
exten => s,n,Set(DIAL_NUMBER=${ARG2})
exten => s,n,Set(DIAL_TRUNK_OPTIONS=${DIAL_OPTIONS})
exten => s,n,Set(OUTBOUND_GROUP=OUT_${DIAL_TRUNK})
exten => s,n,GotoIf($["${OUTMAXCHANS_${DIAL_TRUNK}}foo" = "foo"]?nomax)
exten => s,n,GotoIf($[ ${GROUP_COUNT(OUT_${DIAL_TRUNK})} >= ${OUTMAXCHANS_${DIAL_TRUNK}} ]?chanfull)
exten => s,n(nomax),GotoIf($["${INTRACOMPANYROUTE}" = "YES"]?skipoutcid)
exten => s,n,Set(DIAL_TRUNK_OPTIONS=${TRUNK_OPTIONS})
exten => s,n,Macro({CODE}-outbound-callerid,${DIAL_TRUNK})
exten => s,n(skipoutcid),GosubIf($["${PREFIX_TRUNK_${DIAL_TRUNK}}" != ""]?sub-flp-${DIAL_TRUNK},s,1)
exten => s,n,Set(OUTNUM=${OUTPREFIX_${DIAL_TRUNK}}${DIAL_NUMBER})
exten => s,n,ExecIf($[$["${MOHCLASS}" != "default"] & $["${MOHCLASS}" != ""]]?Set(DIAL_TRUNK_OPTIONS=M(setmusic^${MOHCLASS})${DIAL_TRUNK_OPTIONS}))
exten => s,n(gocall),Macro({CODE}-dialout-dundi-predial-hook,)
exten => s,n,GotoIf($["${PREDIAL_HOOK_RET}" = "BYPASS"]?bypass,1)
exten => s,n,Macro({CODE}-dundi-${DIAL_TRUNK},${OUTNUM})
exten => s,n,Goto(s-${DIALSTATUS},1)
exten => s,n(chanfull),Noop(max channels used up)
exten => s-BUSY,1,Noop(Dial failed due to trunk reporting BUSY - giving up)
exten => s-BUSY,n,Playtones(busy)
exten => s-BUSY,n,Busy(20)
exten => s-ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => s-ANSWER,n,Macro({CODE}-hangupcall,)
exten => s-NOANSWER,1,Noop(Dial failed due to trunk reporting NOANSWER - giving up)
exten => s-NOANSWER,n,Progress
exten => s-NOANSWER,n,Playback(number-not-answering,noanswer)
exten => s-NOANSWER,n,Congestion(20)
exten => s-INVALIDNMBR,1,Noop(Dial failed due to trunk reporting Address Incomplete - giving up)
exten => s-INVALIDNMBR,n,Progress
exten => s-INVALIDNMBR,n,Playback(ss-noservice,noanswer)
exten => s-INVALIDNMBR,n,Busy(20)
exten => s-CHANGED,1,Noop(Dial failed due to trunk reporting Number Changed - giving up)
exten => s-CHANGED,n,Playtones(busy)
exten => s-CHANGED,n,Busy(20)
exten => _s-.,1,Set(RC=${IF($[${ISNULL(${HANGUPCAUSE})}]?0:${HANGUPCAUSE})})
exten => _s-.,n,Goto(${RC},1)
exten => 17,1,Goto(s-BUSY,1)
exten => 18,1,Goto(s-NOANSWER,1)
exten => 22,1,Goto(s-CHANGED,1)
exten => 23,1,Goto(s-CHANGED,1)
exten => 28,1,Goto(s-INVALIDNMBR,1)
exten => _X,1,Goto(continue,1)
exten => _X.,1,Goto(continue,1)
exten => continue,1,GotoIf($["${OUTFAIL_${ARG1}}" = ""]?noreport)
exten => continue,n,AGI(${OUTFAIL_${ARG1}})
exten => continue,n(noreport),Noop(TRUNK Dial failed due to ${DIALSTATUS} HANGUPCAUSE: ${HANGUPCAUSE} - failing through to other trunks)
exten => continue,n,Set(CALLERID(number)=${EXTUSER})
exten => disabletrunk,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} DISABLED - falling through to next trunk)
exten => bypass,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} BYPASSING because dialout-dundi-predial-hook)
exten => h,1,Macro({CODE}-hangupcall,)

; end of [macro-{CODE}-dialout-dundi]


[macro-{CODE}-dialout-enum]
include => macro-{CODE}-dialout-enum-custom
exten => s,1,GosubIf($[$["${ARG3}" != ""] & $["${DB(EXTUSER/{CODE}/${EXTUSER}/pinless)}" != "NOPASSWD"]]?sub-pincheck,s,1)
exten => s,n,Macro({CODE}-outbound-callerid,${ARG1})
exten => s,n,Set(OUTBOUND_GROUP=OUT_${ARG1})
exten => s,n,GotoIf($["${OUTMAXCHANS_${ARG1}}foo" = "foo"]?nomax)
exten => s,n,GotoIf($[ ${GROUP_COUNT(OUT_${ARG1})} >= ${OUTMAXCHANS_${ARG1}} ]?nochans)
exten => s,n(nomax),Set(DIAL_NUMBER=${ARG2})
exten => s,n,Set(DIAL_TRUNK=${ARG1})
exten => s,n,GosubIf($["${PREFIX_TRUNK_${DIAL_TRUNK}}" != ""]?sub-flp-${DIAL_TRUNK},s,1)
exten => s,n,AGI(enumlookup.agi) ; para buscar el los dns de google
exten => s,n(dialloop),GotoIf($["foo${DIALARR}"="foo"]?s-${DIALSTATUS},1)
exten => s,n,Set(TRYDIAL=${CUT(DIALARR,%,1)})
exten => s,n,Set(DIALARR=${CUT(DIALARR,%,2-)})
exten => s,n,Dial(${TRYDIAL},)
exten => s,n,GotoIf($[ $[ "${DIALSTATUS}" = "CHANUNAVAIL" ] | $[ "${DIALSTATUS}" = "CONGESTION" ] ]?dialloop:s-${DIALSTATUS},1)
exten => s,n(nochans),Noop(max channels used up)
exten => s-BUSY,1,Noop(Dial failed due to trunk reporting BUSY - giving up)
exten => s-BUSY,n,Playtones(busy)
exten => s-BUSY,n,Busy(20)
exten => s-ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => s-ANSWER,n,Macro(hangupcall,)
exten => s-NOANSWER,1,Noop(Dial failed due to trunk reporting NOANSWER - giving up)
exten => s-NOANSWER,n,Progress
exten => s-NOANSWER,n,Playback(number-not-answering,noanswer)
exten => s-NOANSWER,n,Congestion(20)
exten => s-INVALIDNMBR,1,Noop(Dial failed due to trunk reporting Address Incomplete - giving up)
exten => s-INVALIDNMBR,n,Progress
exten => s-INVALIDNMBR,n,Playback(ss-noservice,noanswer)
exten => s-INVALIDNMBR,n,Busy(20)
exten => s-CHANGED,1,Noop(Dial failed due to trunk reporting Number Changed - giving up)
exten => s-CHANGED,n,Playtones(busy)
exten => s-CHANGED,n,Busy(20)
exten => _s-.,1,Set(RC=${IF($[${ISNULL(${HANGUPCAUSE})}]?0:${HANGUPCAUSE})})
exten => _s-.,n,Goto(${RC},1)
exten => 17,1,Goto(s-BUSY,1)
exten => 18,1,Goto(s-NOANSWER,1)
exten => 22,1,Goto(s-CHANGED,1)
exten => 23,1,Goto(s-CHANGED,1)
exten => 28,1,Goto(s-INVALIDNMBR,1)
exten => _X,1,Goto(continue,1)
exten => _X.,1,Goto(continue,1)
exten => continue,1,GotoIf($["${OUTFAIL_${ARG1}}" = ""]?noreport)
exten => continue,n,AGI(${OUTFAIL_${ARG1}})
exten => continue,n(noreport),Noop(TRUNK Dial failed due to ${DIALSTATUS} HANGUPCAUSE: ${HANGUPCAUSE} - failing through to other trunks)
exten => continue,n,Set(CALLERID(number)=${EXTUSER})
exten => disabletrunk,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} DISABLED - falling through to next trunk)
exten => bypass,1,Noop(TRUNK: ${OUT_${DIAL_TRUNK}} BYPASSING because dialout-trunk-predial-hook)
exten => h,1,Macro({CODE}-hangupcall,)

; end of [macro-{CODE}-dialout-enum]


; overrides callerid out trunks
; arg1 is trunk
, macro-user-callerid should be called _before_ using this macro

[macro-{CODE}-outbound-callerid]
include => macro-{CODE}-outbound-callerid-custom
exten => s,1,ExecIf($["${CALLINGPRES_SV}" != ""]?Set(CALLERPRES()=${CALLINGPRES_SV}))
exten => s,n,ExecIf($["${REALCALLERIDNUM:1:2}" = ""]?Set(REALCALLERIDNUM=${CALLERID(number)}))
exten => s,n(start),GotoIf($[ $["${REALCALLERIDNUM}" = ""] | $["${KEEPCID}" != "TRUE"] | $["${OUTKEEPCID_${ARG1}}" = "on"] ]?normcid)
exten => s,n,Set(USEROUTCID=${REALCALLERIDNUM})
exten => s,n,GotoIf($["foo${DB(EXTUSER/{CODE}/${REALCALLERIDNUM}/device)}" = "foo"]?bypass)
exten => s,n(normcid),Set(USEROUTCID=${DB(EXTUSER/{CODE}/${EXTUSER}/outboundcid)})
exten => s,n(bypass),Set(EMERGENCYCID=${DB(DEVICE/{CODE}/{CODE}_${REALCALLERIDNUM}/emergency_cid)})
exten => s,n,Set(TRUNKOUTCID=${OUTCID_${ARG1}})
exten => s,n,GotoIf($["${EMERGENCYROUTE:1:2}" = "" | "${EMERGENCYCID:1:2}" = ""]?trunkcid)
exten => s,n,Set(CALLERID(all)=${EMERGENCYCID})
exten => s,n(exit),MacroExit()
exten => s,n(trunkcid),ExecIf($[${LEN(${TRUNKOUTCID})} != 0]?Set(CALLERID(all)=${TRUNKOUTCID}))
exten => s,n(usercid),ExecIf($[${LEN(${USEROUTCID})} != 0]?Set(CALLERID(all)=${USEROUTCID}))
exten => s,n,ExecIf($[${LEN(${TRUNKCIDOVERRIDE})} != 0 | ${LEN(${FORCEDOUTCID_${ARG1}})} != 0]?Set(CALLERID(all)=${IF($[${LEN(${FORCEDOUTCID_${ARG1}})}=0]?${TRUNKCIDOVERRIDE}:${FORCEDOUTCID_${ARG1}})}))
exten => s,n(hidecid),ExecIf($["${CALLERID(name)}"="hidden"]?Set(CALLERPRES()=prohib_passed_screen))
exten => s,n,ExecIf($["${OUTKEEPCID_${ARG1}}" = "cnum"]'?Set(CALLERID(name)=''))

; end of [macro-{CODE}-outbound-callerid]


[{CODE}-from-zaptel]
include => from-{CODE}-zaptel-custom
include => from-{CODE}-dahdi
exten => foo,1,Noop(bar)

; end of [from-zaptel]


[{CODE}-from-dahdi]
include => {CODE}-from-dahdi-custom
exten => _X.,1,Set(DID=${EXTEN})
exten => _X.,n,Goto(s,1)
exten => s,1,Noop(Entering from-dahdi with DID == ${DID})
exten => s,n,Ringing()
exten => s,n,Set(DID=${IF($["${DID}"= ""]?s:${DID})})
exten => s,n,Noop(DID is now ${DID})
exten => s,n,GotoIf($["${CHANNEL:0:5}"="DAHDI"]?dahdiok:checkzap)
exten => s,n(checkzap),GotoIf($["${CHANNEL:0:3}"="Zap"]?zapok:neither)
exten => s,n(neither),Goto({CODE}-from-pstn,${DID},1)
exten => s,n,Macro({CODE}-Hangupcall,dummy)
exten => s,n(dahdiok),Noop(Is a DAHDI Channel)
exten => s,n,Set(CHAN=${CHANNEL:6})
exten => s,n,Set(CHAN=${CUT(CHAN,-,1)})
exten => s,n,Macro({CODE}-from-dahdi-${CHAN},${DID},1)
exten => s,n,Noop(Returned from Macro from-dahdi-${CHAN})
exten => s,n,Goto({CODE}-from-pstn,${DID},1)
exten => s,n(zapok),Noop(Is a Zaptel Channel)
exten => s,n,Set(CHAN=${CHANNEL:4})
exten => s,n,Set(CHAN=${CUT(CHAN,-,1)})
exten => s,n,Macro({CODE}-from-dahdi-${CHAN},${DID},1)
exten => s,n,Noop(Returned from Macro {CODE}-from-dahdi-${CHAN})
exten => s,n,Goto({CODE}-from-pstn,${DID},1)

; end of [from-dahdi]


[macro-{CODE}-user-callerid]
include => macro-{CODE}-user-callerid-custom
exten => s,1,Set(EXTUSER=${IF($["foo${EXTUSER}" = "foo"]?${CALLERID(number)}:${EXTUSER})})
exten => s,n,GotoIf($["${CHANNEL:0:5}" = "Local"]?report)
exten => s,n,ExecIf($["${REALCALLERIDNUM:1:2}" = ""]?Set(REALCALLERIDNUM=${CALLERID(number)}))
exten => s,n,Set(EXTUSER=${DB(DEVICE/{CODE}/{CODE}_${REALCALLERIDNUM}/user)})
exten => s,n,Set(EXTUSERCIDNAME=${DB(EXTUSER/{CODE}/${EXTUSER}/cidname)})
exten => s,n,GotoIf($["x${EXTUSERCIDNAME:1:2}" = "x"]?report)
exten => s,n,Set(EXTUSERCID=${IF($["${DB_EXISTS(EXTUSER/{CODE}/${EXTUSER}/cidnum)}" = "1"]?${DB_RESULT}:${EXTUSER})})
exten => s,n,Set(CALLERID(all)="${EXTUSERCIDNAME}" <${EXTUSERCID}>)
exten => s,n,ExecIf($["${{CODE}_LANGUAGE}" != ""]?Set(CHANNEL(language)=${{CODE}_LANGUAGE}))
exten => s,n,ExecIf($["${DB(EXTUSER/{CODE}/${EXTUSER}/language)}" != ""]?Set(CHANNEL(language)=${DB(EXTUSER/{CODE}/${EXTUSER}/language)}))
exten => s,n(report),GotoIf($[ "${ARG1}" = "SKIPTTL" ]?continue)
exten => s,n(report2),Set(__TTL=${IF($["foo${TTL}" = "foo"]?64:$[ ${TTL} - 1 ])})
exten => s,n,GotoIf($[ ${TTL} > 0 ]?continue)
exten => s,n,Wait(${RINGTIMER})
exten => s,n,Answer
exten => s,n,Wait(2)
exten => s,n,Playback(im-sorry&an-error-has-occured&with&call-forwarding)
exten => s,n,Macro({CODE}-hangupcall,)
exten => s,n,Congestion(20)
exten => s,n(continue),Set(CALLERID(number)=${CALLERID(number):0:40})
exten => s,n,Set(CALLERID(name)=${CALLERID(name):0:40})
exten => s,n,Noop(Using CallerID ${CALLERID(all)})
exten => h,1,Macro({CODE}-hangupcall,)

; end of [macro-{CODE}-user-callerid]


; se usa para llamar a un voicemail especifico
[{CODE}-vm-callme]
include => {CODE}-vm-callme-custom
exten => s,1,Answer
exten => s,n,Wait(1)
exten => s,n(repeat),Background(${MSG}&silence/2&vm-repeat&vm-starmain)
exten => s,n,WaitExten(15,)
exten => 5,1,Goto(s,repeat)
exten => #,1,Playback(vm-goodbye)
exten => #,n,Hangup
exten => *,1,Macro({CODE}-get-vmcontext,${MBOX})
exten => *,n,VoiceMailMain(${MBOX}@${VMCONTEXT},s)
exten => i,1,Playback(pm-invalid-option)
exten => i,n,Goto(s,repeat)
exten => t,1,Playback(vm-goodbye)
exten => t,n,Hangup
exten => h,1,Hangup
exten => s-ANSWER,1,Noop(Call successfully answered - Hanging up now)
exten => s-ANSWER,n,Macro(hangupcall,)

; end of [{CODE}-vm-callme]


;------------------------------------------------------------------------
; [macro-vm]
;------------------------------------------------------------------------
; CONTEXT:      macro-vm
; PURPOSE:      call voicemail system and extend with personal ivr
;
; Under normal use, this macro will call the voicemail system with the extension and
; desired greeting mode of busy, unavailable or as specified with direct voicemail
; calls (usually unavailable) when entered from destinations.
;
; The voicemail system's two greetings have been 'hijacked' as follows to extend the
; system by giving the option of a private 'ivr' for each voicemail user. The following
; applies to both the busy and unavailable modes of voicemail and can be applied to one
; or both, and differently.
; ARG1 - extension
; ARG2 - DIRECTDIAL/BUSY
; ARG3 - RETURN makes macro return, otherwise hangup
;------------------------------------------------------------------------

[macro-{CODE}-vm]
include => macro-{CODE}-vm-custom
exten => s,1,Macro({CODE}-user-callerid,SKIPTTL)
exten => s,n,Set(VMGAIN=${IF($["foo${{CODE}_VM_GAIN}"!="foo"]?"g(${{CODE}_VM_GAIN})":"")})
exten => s,n,GotoIf($["foo${DB(${BLKVM_OVERRIDE})}" != "fooTRUE"]?vmx,1)
exten => s,n,Noop(CAME FROM: ${NODEST} - Blocking VM cause of key: ${DB(BLKVM_OVERRIDE)})
exten => s,n,Hangup
exten => vmx,1,Set(MEXTEN=${ARG1})
exten => vmx,n,Set(MMODE=${ARG2})
exten => vmx,n,Set(RETVM=${ARG3})
exten => vmx,n,Set(MODE=${IF($["${MMODE}"="BUSY"]?busy:unavail)})
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/vmxopts/timeout)}" = "0"]?chknomsg)
exten => vmx,n,Set(VM_OPTS=${DB_RESULT})
exten => vmx,n(chknomsg),GotoIf($["${MMODE}"="NOMESSAGE"]?s-${MMODE},1)
exten => vmx,n,GotoIf($["${MMODE}" != "DIRECTDIAL"]?notdirect)
exten => vmx,n,Set(MODE=${IF($["${REGEX("[b]" ${VM_DDTYPE})}" = "1"]?busy:${MODE})})
exten => vmx,n(notdirect),Noop(Checking if ext ${MEXTEN} is enabled: ${DB(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/state)})
exten => vmx,n,GotoIf($["${DB(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/state)}" != "enabled"]?s-${MMODE},1)
exten => vmx,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => vmx,n,GotoIf($[(${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/temp.wav)} = 1) || (${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/temp.WAV)} = 1)]?tmpgreet)
exten => vmx,n,GotoIf($[(${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/${MODE}.wav)} = 0) && (${STAT(f,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/${MODE}.WAV)} = 0)]?nofile)
exten => vmx,n,Set(LOOPCOUNT=0)
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/repeat)}" = "0"]?vmxtime)
exten => vmx,n,Set(VMX_REPEAT=${DB_RESULT})
exten => vmx,n(vmxtime),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/timeout)}" = "0"]?vmxloops)
exten => vmx,n,Set(VMX_TIMEOUT=${DB_RESULT})
exten => vmx,n(vmxloops),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/loops)}" = "0"]?vmxanswer)
exten => vmx,n,Set(VMX_LOOPS=${DB_RESULT})
exten => vmx,n(vmxanswer),Answer
exten => vmx,n(loopstart),Read(ACTION,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${MEXTEN}/${MODE},1,skip,${VMX_REPEAT},${VMX_TIMEOUT})
exten => vmx,n,GotoIf($["${EXISTS(${ACTION})}" = "1"]?checkopt)
exten => vmx,n(noopt),Noop(Timeout: going to timeout dest)
exten => vmx,n,Set(VMX_OPTS=${VMX_OPTS_TIMEOUT})
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/vmxopts/timeout)}" = "0"]?chktime)
exten => vmx,n,Set(VMX_OPTS=${DB_RESULT})
exten => vmx,n(chktime),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/timedest/ext)}" = "0"]?dotime)
exten => vmx,n,Set(VMX_TIMEDEST_EXT=${DB_RESULT})
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/CODE}/${MEXTEN}/vmx/${MODE}/timedest/context)}" = "0"]?timepri)
exten => vmx,n,Set(VMX_TIMEDEST_CONTEXT=${DB_RESULT})
exten => vmx,n(timepri),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/timedest/pri)}" = "0"]?dotime)
exten => vmx,n,Set(VMX_TIMEDEST_PRI=${DB_RESULT})
exten => vmx,n(dotime),Goto(${VMX_TIMEDEST_CONTEXT},${VMX_TIMEDEST_EXT},${VMX_TIMEDEST_PRI})
exten => vmx,n(checkopt),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/${ACTION}/ext)}" = "1"]?doopt)
exten => vmx,n,GotoIf($["${ACTION}" = "0"]?o,1)
exten => vmx,n,GotoIf($["${ACTION}" = "*"]?adef,1)
exten => vmx,n,Set(LOOPCOUNT=$[${LOOPCOUNT} + 1])
exten => vmx,n,GotoIf($[${LOOPCOUNT} > ${VMX_LOOPS}]?toomany)
exten => vmx,n,Playback(pm-invalid-option&please-try-again)
exten => vmx,n,Goto(loopstart)
exten => vmx,n(toomany),Noop(Too Many invalid entries, got to invalid dest)
exten => vmx,n,Set(VMX_OPTS=${VMX_OPTS_LOOPS})
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/vmxopts/loops)}" = "0"]?chkloop)
exten => vmx,n,Set(VMX_OPTS=${DB_RESULT})
exten => vmx,n(chkloop),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/loopdest/ext)}" = "0"]?doloop)
exten => vmx,n,Set(VMX_LOOPDEST_EXT=${DB_RESULT})
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/loopdest/context)}" = "0"]?looppri)
exten => vmx,n,Set(VMX_LOOPDEST_CONTEXT=${DB_RESULT})
exten => vmx,n(looppri),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/loopdest/pri)}" = "0"]?doloop)
exten => vmx,n,Set(VMX_LOOPDEST_PRI=${DB_RESULT})
exten => vmx,n(doloop),Goto(${VMX_LOOPDEST_CONTEXT},${VMX_LOOPDEST_EXT},${VMX_LOOPDEST_PRI})
exten => vmx,n(doopt),Noop(Got a valid option: ${DB_RESULT})
exten => vmx,n,Set(VMX_EXT=${DB_RESULT})
exten => vmx,n,GotoIf($["${VMX_EXT}" != "dovm"]?getdest)
exten => vmx,n(vmxopts),Set(VMX_OPTS=${VMX_OPTS_DOVM})
exten => vmx,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/vmxopts/dovm)}" = "0"]?vmxdovm)
exten => vmx,n(vmxopts),Set(VMX_OPTS=${DB_RESULT})
exten => vmx,n(vmxdovm),Goto(dovm,1)
exten => vmx,n(getdest),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/${ACTION}/context)}" = "0"]?vmxpri)
exten => vmx,n,Set(VMX_CONTEXT=${DB_RESULT})
exten => vmx,n(vmxpri),GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/${ACTION}/pri)}" = "0"]?vmxgoto)
exten => vmx,n,Set(VMX_PRI=${DB_RESULT})
exten => vmx,n(vmxgoto),Goto(${VMX_CONTEXT},${VMX_EXT},${VMX_PRI})
exten => vmx,n(nofile),Noop(File for mode: ${MODE} does not exist, SYSTEMSTATUS: ${SYSTEMSTATUS}, going to normal voicemail)
exten => vmx,n,Goto(s-${MMODE},1)
exten => vmx,n(tmpgreet),Noop(Temporary Greeting Detected, going to normal voicemail)
exten => vmx,n,Goto(s-${MMODE},1)
exten => dovm,1,Noop(VMX Timeout - go to voicemail)
exten => dovm,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${VMX_OPTS}${VMGAIN})
exten => dovm,n,Goto(exit-${VMSTATUS},1)
exten => s-BUSY,1,Noop(BUSY voicemail)
exten => s-BUSY,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => s-BUSY,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${VM_OPTS}b${VMGAIN})
exten => s-BUSY,n,Goto(exit-${VMSTATUS},1)
exten => s-NOMESSAGE,1,Noop(NOMESSAGE (beeb only) voicemail)
exten => s-NOMESSAGE,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => s-NOMESSAGE,n,VoiceMail(${MEXTEN}@${VMCONTEXT},s${VM_OPTS}${VMGAIN})
exten => s-NOMESSAGE,n,Goto(exit-${VMSTATUS},1)
exten => s-DIRECTDIAL,1,Noop(DIRECTDIAL voicemail)
exten => s-DIRECTDIAL,n,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => s-DIRECTDIAL,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${VM_OPTS}${VM_DDTYPE}${VMGAIN})
exten => s-DIRECTDIAL,n,Goto(exit-${VMSTATUS},1)
exten => _s-.,1,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => _s-.,n,VoiceMail(${MEXTEN}@${VMCONTEXT},${VM_OPTS}u${VMGAIN})
exten => _s-.,n,Goto(exit-${VMSTATUS},1)
exten => o,1,Playback(one-moment-please)
exten => o,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/0/ext)}" = "0"]?doopdef)
exten => o,n,Set(VMX_OPDEST_EXT=${DB_RESULT})
exten => o,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/0/context)}" = "1"]?opcontext)
exten => o,n,Set(DB_RESULT=${VMX_CONTEXT})
exten => o,n(opcontext),Set(VMX_OPDEST_CONTEXT=${DB_RESULT})
exten => o,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/0/pri)}" = "1"]?oppri)
exten => o,n,Set(DB_RESULT=${VMX_PRI})
exten => o,n(oppri),Set(VMX_OPDEST_PRI=${DB_RESULT})
exten => o,n,Goto(${VMX_OPDEST_CONTEXT},${VMX_OPDEST_EXT},${VMX_OPDEST_PRI})
exten => o,n(doopdef),GotoIf($["x${OPERATOR_XTN}"="x"]?nooper:{CODE}-from-internal,${OPERATOR_XTN},1)
exten => o,n(nooper),GotoIf($["x${FROM_DID}"="x"]?nodid)
exten => o,n,Dial(Local/${FROM_DID}@{CODE}-from-pstn,)
exten => o,n,Macro(hangup,)
exten => o,n(nodid),Dial(Local/s@{CODE}-from-pstn,)
exten => o,n,Macro({CODE}-hangup,)
exten => a,1,Macro({CODE}-get-vmcontext,${MEXTEN})
exten => a,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/*/ext)}" = "0"]?adef,1)
exten => a,n,Set(VMX_ADEST_EXT=${DB_RESULT})
exten => a,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/*/context)}" = "1"]?acontext)
exten => a,n,Set(DB_RESULT=${VMX_CONTEXT})
exten => a,n(acontext),Set(VMX_ADEST_CONTEXT=${DB_RESULT})
exten => a,n,GotoIf($["${DB_EXISTS(EXTUSER/{CODE}/${MEXTEN}/vmx/${MODE}/*/pri)}" = "1"]?apri)
exten => a,n,Set(DB_RESULT=${VMX_PRI})
exten => a,n(apri),Set(VMX_ADEST_PRI=${DB_RESULT})
exten => a,n,Goto(${VMX_ADEST_CONTEXT},${VMX_ADEST_EXT},${VMX_ADEST_PRI})
exten => adef,1,VoiceMailMain(${MEXTEN}@${VMCONTEXT})
exten => adef,n,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => adef,n,Hangup
exten => exit-FAILED,1,Playback(im-sorry&an-error-has-occured)
exten => exit-FAILED,n,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => exit-FAILED,n,Hangup
exten => exit-SUCCESS,1,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => exit-SUCCESS,n,Playback(goodbye)
exten => exit-SUCCESS,n,Hangup
exten => exit-USEREXIT,1,GotoIf($["${RETVM}" = "RETURN"]?exit-RETURN,1)
exten => exit-USEREXIT,n,Playback(goodbye)
exten => exit-USEREXIT,n,Hangup
exten => exit-RETURN,1,Noop(Returning From Voicemail because macro)
exten => t,1,Hangup

; end of [macro-{CODE}-vm]


[macro-{CODE}-exten-vm]
include => macro-{CODE}-exten-vm-custom
exten => s,1,Macro({CODE}-user-callerid,)
exten => s,n,Set(RingGroupMethod=none)
exten => s,n,Set(VMBOX=${ARG1})
exten => s,n,Set(__EXTTOCALL=${ARG2})
exten => s,n,Set(CFUEXT=${DB(CFU/{CODE}/${EXTTOCALL})})
exten => s,n,Set(CFBEXT=${DB(CFB/{CODE}/${EXTTOCALL})})
exten => s,n,Set(RT=${IF($[$["${VMBOX}"!="novm"] | $["${CFUEXT}"!=""]]?${RINGTIMER}:"")})
exten => s,n(checkrecord),Macro({CODE}-record-enable,${EXTTOCALL},IN)
exten => s,n(macrodial),Macro({CODE}-dial-one,${RT},${DIAL_OPTIONS},${EXTTOCALL})
exten => s,n,GotoIf($["${VMBOX}"!="novm" & "${SCREEN}"!="" & "${DIALSTATUS}"="NOANSWER"]?exit)
exten => s,n,Set(SV_DIALSTATUS=${DIALSTATUS})
exten => s,n(calldocfu),GosubIf($[("${SV_DIALSTATUS}"="NOANSWER"|"${SV_DIALSTATUS}"="CHANUNAVAIL") & "${CFUEXT}"!="" & "${SCREEN}"=""]?docfu,1)
exten => s,n(calldocfb),GosubIf($["${SV_DIALSTATUS}"="BUSY" & "${CFBEXT}"!=""]?docfb,1)
exten => s,n,Set(DIALSTATUS=${SV_DIALSTATUS})
exten => s,n,Noop(Voicemail is '${VMBOX}')
exten => s,n,GotoIf($["${VMBOX}"="novm"]?s-${DIALSTATUS},1)
exten => s,n,Noop(Sending to Voicemail box ${EXTTOCALL})
exten => s,n,Macro({CODE}-vm,${VMBOX},${DIALSTATUS},${IVR_RETVM})
exten => docfu,1(docfu),Set(RTCFU=${IF($["${VMBOX}"!="novm"]?${RINGTIMER}:"")})
exten => docfu,n,Dial(Local/${CFUEXT}@{CODE}-from-internal/n,${RTCFU},${DIAL_OPTIONS})
exten => docfu,n,Return()
exten => docfb,1(docfb),Set(RTCFB=${IF($["${VMBOX}"!="novm"]?${RINGTIMER}:"")})
exten => docfb,n,Dial(Local/${CFBEXT}@{CODE}-from-internal/n,${RTCFB},${DIAL_OPTIONS})
exten => docfb,n,Return()
exten => s-BUSY,1,Noop(Extension is reporting BUSY and not passing to Voicemail)
exten => s-BUSY,n,GotoIf($["${IVR_RETVM}"="RETURN" & "${IVR_CONTEXT}"!=""]?exit,1)
exten => s-BUSY,n,Playtones(busy)
exten => s-BUSY,n,Busy(20)
exten => _s-!,1,Noop(IVR_RETVM: ${IVR_RETVM} IVR_CONTEXT: ${IVR_CONTEXT})
exten => _s-!,n,GotoIf($["${IVR_RETVM}"="RETURN" & "${IVR_CONTEXT}"!=""]?exit,1)
exten => _s-!,n,Playtones(congestion)
exten => _s-!,n,Congestion(10)
exten => exit,1,Playback(beep&line-busy-transfer-menu&silence/1)
exten => exit,n,MacroExit()

; end of [macro-exten-vm]


[macro-{CODE}-simple-dial]
include => macro-{CODE}-simple-dial-custom
exten => s,1,Set(__EXTTOCALL=${ARG1})
exten => s,n,Set(RT=${ARG2})
exten => s,n,Set(CFUEXT=${DB(CFU/{CODE}/${EXTTOCALL})})
exten => s,n,Set(CFBEXT=${DB(CFB/{CODE}/${EXTTOCALL})})
exten => s,n,Set(CWI_TMP=${CWIGNORE})
exten => s,n(macrodial),Macro({CODE}-dial-one,${RT},${DIAL_OPTIONS},${EXTTOCALL})
exten => s,n,Set(__CWIGNORE=${CWI_TMP})
exten => s,n,Set(PR_DIALSTATUS=${DIALSTATUS})
exten => s,n(calldocfu),GosubIf($["${PR_DIALSTATUS}"="NOANSWER" & "${CFUEXT}"!=""]?docfu,1)
exten => s,n(calldocfb),GosubIf($["${PR_DIALSTATUS}"="BUSY" & "${CFBEXT}"!=""]?docfb,1)
exten => s,n,Set(DIALSTATUS=${PR_DIALSTATUS})
exten => s,n,Goto(s-${DIALSTATUS},1)
exten => docfu,1,GotoIf($["${DB(EXTUSER/{CODE}/${CFUEXT}/device)}" = "" ]?chlocal)
exten => docfu,n,Dial(Local/${CFUEXT}@{CODE}-ext-local,${RT},${DIAL_OPTIONS})
exten => docfu,n,Return()
exten => docfu,n(chlocal),Dial(Local/${CFUEXT}@{CODE}-from-internal/n,${RT},${DIAL_OPTIONS})
exten => docfu,n,Return()
exten => docfb,1,GotoIf($["${DB(EXTUSER/{CODE}/${CFBEXT}/device)}" = "" ]?chlocal)
exten => docfb,n,Dial(Local/${CFBEXT}@{CODE}-ext-local,${RT},${DIAL_OPTIONS})
exten => docfb,n,Return()
exten => docfb,n(chlocal),Dial(Local/${CFBEXT}@{CODE}-from-internal/n,${RT},${DIAL_OPTIONS})
exten => docfb,n,Return()
exten => _s-.,1,Noop(Extension is reporting ${EXTEN})

; end of [macro-{CODE}-simple-dial]


[macro-{CODE}-dial-one]
include => macro-{CODE}-dial-one-custom
exten => s,1,Set(DEXTEN=${ARG3})
exten => s,n,Set(DIALSTATUS_CW=)
exten => s,n,GosubIf($["${FROM_DID}"!="" & "${SCREEN}"="" & "${DB(EXTUSER/{CODE}/${DEXTEN}/screen)}"!=""]?screen,1)
exten => s,n,GosubIf($["${DB(CF/{CODE}/${DEXTEN})}"!=""]?cf,1)
exten => s,n,GotoIf($["${DEXTEN:-1}"="#" | "${DB(DND/{CODE}/${DEXTEN})}"=""]?skip1)
exten => s,n,Set(DEXTEN=)
exten => s,n,Set(DIALSTATUS=BUSY)
exten => s,n(skip1),GotoIf($["${DEXTEN}"=""]?nodial)
exten => s,n,GotoIf($["${DEXTEN:-1}"="#"]?continue)
exten => s,n,Set(EXTHASCW=${IF($["${CWIGNORE}"!=""]?"":${DB(CW/{CODE}/${DEXTEN})})})
exten => s,n,GotoIf($["${EXTHASCW}"="" | "${DB(CFB/{CODE}/${DEXTEN})}"!="" | "${DB(CFU/{CODE}/${DEXTEN})}"!=""]?next1:cwinusebusy)
exten => s,n(next1),GotoIf($["${DB(CFU/{CODE}/${DEXTEN})}"!="" & ("${EXTENSION_STATE(${DEXTEN})}"="UNAVAILABLE" | "${EXTENSION_STATE(${DEXTEN})}"="UNKNOWN")]?docfu:skip3)
exten => s,n(docfu),Set(DEXTEN=)
exten => s,n,Set(DIALSTATUS=NOANSWER)
exten => s,n,Goto(nodial)
exten => s,n(skip3),GotoIf($["${EXTHASCW}"="" | "${DB(CFB/{CODE}/${DEXTEN})}"!=""]?next2:continue)
exten => s,n(next2),GotoIf($["${EXTENSION_STATE(${DEXTEN})}"="NOT_INUSE" | "${EXTENSION_STATE(${DEXTEN})}"="UNAVAILABLE" | "${EXTENSION_STATE(${DEXTEN})}"="UNKNOWN"]?continue)
exten => s,n,ExecIf($["${DB(CFB/{CODE}/${DEXTEN})}"!="" & "${CFIGNORE}"=""]?Set(DIALSTATUS=BUSY))
exten => s,n,GotoIf($["${EXTHASCW}"!="" | "${DEXTEN:-1}"="#"]?cwinusebusy)
exten => s,n,Set(DEXTEN=)
exten => s,n,Set(DIALSTATUS=BUSY)
exten => s,n,Goto(nodial)
exten => s,n(cwinusebusy),GotoIf($["${EXTHASCW}"!="" & "${CWINUSEBUSY}"!=""]?next3:continue)
exten => s,n(next3),ExecIf($["${EXTENSION_STATE(${DEXTEN})}"!="UNAVAILABLE" & "${EXTENSION_STATE(${DEXTEN})}"!="NOT_INUSE" & "${EXTENSION_STATE(${DEXTEN})}"!="UNKNOWN"]?Set(DIALSTATUS_CW=BUSY))
exten => s,n(continue),GotoIf($["${DEXTEN}"=""]?nodial)
exten => s,n,GosubIf($["${DEXTEN:-1}"!="#"]?dstring,1:dlocal,1)
exten => s,n,GotoIf($[${LEN(${DSTRING})}=0]?nodial)
exten => s,n,GotoIf($["${DEXTEN:-1}"!="#"]?skiptrace)
exten => s,n,GosubIf($[${REGEX("^[\+]?[0-9]+$" ${CALLERID(number)})} = 1]?ctset,1:ctclear,1)
exten => s,n(skiptrace),Set(D_OPTIONS=${IF($["${NODEST}"!="" & ${REGEX("(M[(]auto-blkvm[)])" ${ARG2})} != 1]?${ARG2}M(auto-blkvm):${ARG2})})
exten => s,n,ExecIf($["${ALERT_INFO}"!=""]?SIPAddHeader(Alert-Info: ${ALERT_INFO}))
exten => s,n,ExecIf($["${SIPADDHEADER}"!=""]?SIPAddHeader(${SIPADDHEADER}))
exten => s,n,ExecIf($["${MOHCLASS}"!=""]?Set(CHANNEL(musicclass)=${MEETME_MUSIC}))
exten => s,n,GosubIf($["${QUEUEWAIT}"!=""]?qwait,1)
exten => s,n,Set(__CWIGNORE=${CWIGNORE})
exten => s,n,Set(__KEEPCID=TRUE)
exten => s,n,Dial(${DSTRING},${ARG1},${D_OPTIONS})
exten => s,n,ExecIf($["${DIALSTATUS_CW}"!=""]?Set(DIALSTATUS=${DIALSTATUS_CW}))
exten => s,n,GosubIf($["${SCREEN}"!=""|"${DIALSTATUS}"="ANSWER"]?s-${DIALSTATUS},1)
exten => s,n,MacroExit()
exten => s,n(nodial),ExecIf($["${DIALSTATUS}" = ""]?Set(DIALSTATUS=NOANSWER))
exten => s,n,Noop(Returned from dial-one with nothing to call and DIALSTATUS: ${DIALSTATUS})
exten => s,n,MacroExit()
exten => h,1,Macro({CODE}-hangupcall,)
exten => screen,1,GotoIf($["${DB(EXTUSER/{CODE}/${DEXTEN}/screen)}"!="nomemory" | "${CALLERID(number)}"=""]?memory)
exten => screen,n,ExecIf($[${REGEX("^[0-9a-zA-Z ]+$" ${CALLERID(number)})} = 1]?System(rm -f ${ASTVARLIBDIR}/sounds/priv-callerintros/{dominio}/${CALLERID(number)}.*))
exten => screen,n(memory),Set(__SCREEN=${DB(EXTUSER/{CODE}/${DEXTEN}/screen)})
exten => screen,n,Set(__SCREEN_EXTEN=${DEXTEN})
exten => screen,n,Set(ARG2=${ARG2}p)
exten => screen,n,Return()
exten => cf,1,Set(CFEXTUSER=${IF($["${EXTUSER}"=""]?${CALLERID(number)}:${EXTUSER})})
exten => cf,n,ExecIf($["${DB(CF/{CODE}/${DEXTEN})}"="${CFEXTUSER}" | "${DB(CF/{CODE}/${DEXTEN})}"="${REALCALLERIDNUM}" | "${CUT(CUT(BLINDTRANSFER,-,1),/,1)}" = "${DB(CF/{CODE}/${DEXTEN})}" | "${DEXTEN}"="${DB(CF/{CODE}/${DEXTEN})}"]?Return())
exten => cf,n,Set(DEXTEN=${IF($["${CFIGNORE}"=""]?"${DB(CF/{CODE}/${DEXTEN})}#":"")})
exten => cf,n,ExecIf($["${DEXTEN}"!=""]?Return())
exten => cf,n,Set(DIALSTATUS=NOANSWER)
exten => cf,n,Return()
exten => qwait,1,ExecIf($["${SAVEDCIDNAME}" = ""]?Set(__SAVEDCIDNAME=${CALLERID(name)}))
exten => qwait,n,Set(ELAPSED=${MATH($[${EPOCH}+30-${QUEUEWAIT}]/60,int)})
exten => qwait,n,Set(CALLERID(name)=M${ELAPSED}:${SAVEDCIDNAME})
exten => qwait,n,Return()
exten => ctset,1,Set(DB(CALLTRACE/{CODE}/${DEXTEN})=${CALLERID(number)})
exten => ctset,n,Return()
exten => ctclear,1,Noop(Deleting: CALLTRACE/{CODE}/${DEXTEN} ${DB_DELETE(CALLTRACE/{CODE}/${DEXTEN})})
exten => ctclear,n,Return()
exten => dstring,1,Set(DSTRING=)
exten => dstring,n,Set(DEVICES=${DB(EXTUSER/{CODE}/${DEXTEN}/device)})
exten => dstring,n,ExecIf($["${DEVICES}"=""]?Return())
exten => dstring,n,ExecIf($["${DEVICES:0:1}"="&"]?Set(DEVICES=${DEVICES:1}))
exten => dstring,n,Set(LOOPCNT=${FIELDQTY(DEVICES,&)})
exten => dstring,n,Set(ITER=1)
exten => dstring,n(begin),Set(THISDIAL=${DB(DEVICE/{CODE}/${CUT(DEVICES,&,${ITER})}/dial)})
exten => dstring,n,GosubIf($["${ASTCHANDAHDI}" != ""]?zap2dahdi,1)
exten => dstring,n,Set(DSTRING=${DSTRING}${THISDIAL}&)
exten => dstring,n,Set(ITER=$[${ITER}+1])
exten => dstring,n,GotoIf($[${ITER}<=${LOOPCNT}]?begin)
exten => dstring,n,Set(DSTRING=${DSTRING:0:$[${LEN(${DSTRING})}-1]})
exten => dstring,n,Return()
exten => dlocal,1,Set(DSTRING=Local/${DEXTEN:0:${MATH(${LEN(${DEXTEN})}-1,int)}}@{CODE}-from-internal/n)
exten => dlocal,n,Return()
exten => zap2dahdi,1,ExecIf($["${THISDIAL}" = ""]?Return())
exten => zap2dahdi,n,Set(NEWDIAL=)
exten => zap2dahdi,n,Set(LOOPCNT2=${FIELDQTY(THISDIAL,&)})
exten => zap2dahdi,n,Set(ITER2=1)
exten => zap2dahdi,n(begin2),Set(THISPART2=${CUT(THISDIAL,&,${ITER2})})
exten => zap2dahdi,n,ExecIf($["${THISPART2:0:3}" = "ZAP"]?Set(THISPART2=DAHDI${THISPART2:3}))
exten => zap2dahdi,n,Set(NEWDIAL=${NEWDIAL}${THISPART2}&)
exten => zap2dahdi,n,Set(ITER2=$[${ITER2} + 1])
exten => zap2dahdi,n,GotoIf($[${ITER2} <= ${LOOPCNT2}]?begin2)
exten => zap2dahdi,n,Set(THISDIAL=${NEWDIAL:0:$[${LEN(${NEWDIAL})}-1]})
exten => zap2dahdi,n,Return()
exten => s-NOANSWER,1,Macro({CODE}-vm,${SCREEN_EXTEN},BUSY,${IVR_RETVM})
exten => s-NOANSWER,n,ExecIf($["${IVR_RETVM}"!="RETURN" | "${IVR_CONTEXT}"=""]?Hangup())
exten => s-NOANSWER,n,Return()
exten => s-TORTURE,1,Goto({CODE}-app-blackhole,musiconhold,1)
exten => s-TORTURE,n,Macro({CODE}-hangupcall,)
exten => s-DONTCALL,1,Answer
exten => s-DONTCALL,n,Wait(1)
exten => s-DONTCALL,n,Zapateller()
exten => s-DONTCALL,n,Playback(ss-noservice)
exten => s-DONTCALL,n,Macro({CODE}-hangupcall,)
; end of [macro-{CODE}-dial-one]


[macro-{CODE}-hangupcall]
include => macro-hangupcall-custom

; Validar si el archivo de MixMon existe. Puede no existir si la llamada cuelga
; del lado origen antes que el destino conteste (Elastix bug #422)
exten => s,1,GotoIf($["${CDR(userfield)}" = ""]?endmixmoncheck)
; Este codigo es fragil. Actualizar si se averigua la manera de consultar AST_MONITOR_DIR
exten => s,n,Set(MIXMON_CALLFILENAME=/var/spool/asterisk/monitor/{dominio}/${CALLFILENAME}.${MIXMON_FORMAT})
exten => s,n,GotoIf($["${MIXMON_DIR}" = ""]?defaultmixmondir)
exten => s,n,Set(MIXMON_CALLFILENAME=${CALLFILENAME}.${MIXMON_FORMAT})
exten => s,n(defaultmixmondir),System(test -e ${MIXMON_CALLFILENAME})
exten => s,n,Noop(SYSTEMSTATUS = ${SYSTEMSTATUS})
exten => s,n,GotoIf($["${SYSTEMSTATUS}" = "SUCCESS"]?endmixmoncheck)
; Si archivo MixMon no existe, se anula CDR(userfield)
exten => s,n,Set(CDR(userfield)=)
exten => s,n(endmixmoncheck),Noop(End of MIXMON check)

; Validar si existe el archivo de grabacion de MeetMe. Puede que el archivo de
; grabacion sea distinto del especificado en el contexto, porque solo obedece
; la asignacion del primer conferencista que entra a la conferencia.
exten => s,n,GotoIf($["${MEETME_RECORDINGFILE}" = ""]?nomeetmemon)
exten => s,n,GotoIf($["${MEETME_RECORDINGFILE}" = "${MEETME_ACTUAL_RECORDINGFILE}"]?nomeetmemon2)
exten => s,n,System(ln ${MEETME_ACTUAL_RECORDINGFILE}.${MIXMON_FORMAT} ${MEETME_RECORDINGFILE}.${MIXMON_FORMAT})
exten => s,n(nomeetmemon2),Noop(MEETME_RECORDINGFILE and MEETME_ACTUAL_RECORDINGFILE are identical.)
exten => s,n,Set(CDR(userfield)=audio:${MEETME_RECORDINGFILE}.${MIXMON_FORMAT})
exten => s,n(nomeetmemon),Noop(MEETME_RECORDINGFILE=${MEETME_RECORDINGFILE})

; Validar si existe el archivo de grabacion bajo demanda para la extension
exten => s,n,GotoIf($["${TOUCH_MONITOR_OUTPUT}" = ""]?noautomon)
exten => s,n,Set(CDR(userfield)=audio:${TOUCH_MONITOR_OUTPUT}.${MIXMON_FORMAT})
exten => s,n(noautomon),Noop(TOUCH_MONITOR_OUTPUT=${TOUCH_MONITOR_OUTPUT})

; Validar si existe el archivo de grabacion de la cola
exten => s,n,GotoIf($["${MONITOR_FILENAME}" = ""]?noautomon2)
exten => s,n,System(test -e ${MONITOR_FILENAME}*)
exten => s,n,Noop(SYSTEMSTATUS = ${SYSTEMSTATUS})
exten => s,n,GotoIf($["${SYSTEMSTATUS}" = "APPERROR"]?errornoautomon)
exten => s,n,Set(CDR(userfield)=audio:${MONITOR_FILENAME})
exten => s,n(errornoautomon),Noop(End of MONITOR QUEUE check)
exten => s,n(noautomon2),Noop(MONITOR_FILENAME=${MONITOR_FILENAME})

exten => s,n(start),GotoIf($["${USE_CONFIRMATION}"="" | "${RINGGROUP_INDEX}"="" | "${CHANNEL}"!="${UNIQCHAN}"]?skiprg)
exten => s,n,Noop(Cleaning Up Confirmation Flag: RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL})
exten => s,n(delrgi),Noop(Deleting: RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL} ${DB_DELETE(RG/{CODE}/${RINGGROUP_INDEX}/${CHANNEL})})
exten => s,n(skiprg),GotoIf($["${BLKVM_BASE}"="" | "BLKVM/${BLKVM_BASE}/${CHANNEL}"!="${BLKVM_OVERRIDE}"]?skipblkvm)
exten => s,n,Noop(Cleaning Up Block VM Flag: ${BLKVM_OVERRIDE})
exten => s,n(delblkvm),Noop(Deleting: ${BLKVM_OVERRIDE} ${DB_DELETE(${BLKVM_OVERRIDE})})
exten => s,n(skipblkvm),GotoIf($["${FMGRP}"="" | "${FMUNIQUE}"="" | "${CHANNEL}"!="${FMUNIQUE}"]?theend)
exten => s,n(delfmrgp),Noop(Deleting: FM/DND/{CODE}/${FMGRP}/${CHANNEL} ${DB_DELETE(FM/DND/{CODE}/${FMGRP}/${CHANNEL})})
exten => s,n(theend),Hangup
